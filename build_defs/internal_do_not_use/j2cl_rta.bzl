"""j2cl_rta build rule.

Run the rta algorithm against a call graph generated by j2cl.
"""

load(
    "//build_defs/internal_do_not_use:j2cl_common.bzl",
    "J2clInfo",
)
load(
    "//build_defs/internal_do_not_use:rta_utils.bzl",
    "RTA_ASPECT_ATTRS",
    "pmf_file_aspect",
    "write_module_names_file",
)

_TransitiveLibraryInfo = provider(fields = ["files"])
_J2clRtaInfo = provider()

def _library_info_aspect_impl(target, ctx):
    library_info_file = target[J2clInfo]._private_.library_info if J2clInfo in target else []

    # Because the aspect propagates along attributes listed in _RTA_ASPECT_ATTRS,
    # the aspect has been previously applied to targets listed in those attributes.
    # We can safely assume that _TransitiveLibraryInfo exists on those targets.
    transitive_library_infos = []
    for attr in RTA_ASPECT_ATTRS:
        if hasattr(ctx.rule.attr, attr):
            transitive_library_infos += [
                target[_TransitiveLibraryInfo].files
                for target in getattr(ctx.rule.attr, attr)
            ]

    return [_TransitiveLibraryInfo(
        files = depset(library_info_file, transitive = transitive_library_infos),
    )]

_library_info_aspect = aspect(
    attr_aspects = RTA_ASPECT_ATTRS,
    provides = [_TransitiveLibraryInfo],
    implementation = _library_info_aspect_impl,
)

def _j2cl_rta_impl(ctx):
    # our rule can assume that "_TransitiveLibraryInfo" provider is present in all of its
    # dependencies because the aspect have been applied on them.
    all_library_info_files = depset(
        transitive = [t[_TransitiveLibraryInfo].files for t in ctx.attr.targets],
    ).to_list()

    unused_types_list = ctx.outputs.unused_types_list
    unused_members_list = ctx.outputs.unused_members_list
    removal_code_info_file = ctx.outputs.removal_code_info_file

    rta_args = ctx.actions.args()
    rta_args.use_param_file("@%s", use_always = True)
    rta_args.add("--unusedTypesOutput", unused_types_list)
    rta_args.add("--unusedMembersOutput", unused_members_list)
    rta_args.add("--removalCodeInfoOutput", removal_code_info_file)
    rta_args.add_all(all_library_info_files)

    # Run rta algorithm
    ctx.actions.run(
        inputs = all_library_info_files,
        outputs = [unused_types_list, unused_members_list, removal_code_info_file],
        arguments = [rta_args],
        progress_message = "Running J2CL rapid type analysis",
        executable = ctx.executable._rta_runner,
        execution_requirements = {"supports-workers": "1"},
        mnemonic = "J2clRta",
    )

    # Store module names in a file so they can be accessed later
    write_module_names_file(ctx)

    return [
        _J2clRtaInfo(
            unused_types_list = unused_types_list,
            removal_code_info_file = removal_code_info_file,
            unused_members_list = unused_members_list,
        ),
    ]

j2cl_rta = rule(
    attrs = {
        # TODO(b/114732596): Add a check on targets provided in "targets" field.
        "targets": attr.label_list(aspects = [_library_info_aspect, pmf_file_aspect]),
        "_rta_runner": attr.label(
            cfg = "host",
            executable = True,
            default = Label(
                "//tools/java/com/google/j2cl/tools/rta:J2clRta_worker",
            ),
        ),
    },
    outputs = {
        "unused_types_list": "%{name}_unused_types.list",
        "unused_members_list": "%{name}_unused_members.list",
        "removal_code_info_file": "%{name}_removal_code_info",
        "module_name_list": "%{name}_module_names.list",
    },
    implementation = _j2cl_rta_impl,
)
