/*
 * Copyright 2023 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package com.google.j2cl.transpiler.backend.kotlin

import com.google.common.base.CaseFormat
import com.google.j2cl.transpiler.ast.CompilationUnit
import com.google.j2cl.transpiler.ast.DeclaredTypeDescriptor
import com.google.j2cl.transpiler.ast.FieldDescriptor
import com.google.j2cl.transpiler.ast.Method
import com.google.j2cl.transpiler.ast.MethodDescriptor
import com.google.j2cl.transpiler.ast.PrimitiveTypeDescriptor
import com.google.j2cl.transpiler.ast.PrimitiveTypes
import com.google.j2cl.transpiler.ast.Type
import com.google.j2cl.transpiler.ast.TypeDeclaration
import com.google.j2cl.transpiler.ast.TypeDescriptor
import com.google.j2cl.transpiler.ast.TypeDescriptors.isJavaLangObject
import com.google.j2cl.transpiler.ast.TypeDescriptors.isPrimitiveVoid
import com.google.j2cl.transpiler.ast.Variable
import com.google.j2cl.transpiler.backend.kotlin.common.buildList
import com.google.j2cl.transpiler.backend.kotlin.common.letIf
import com.google.j2cl.transpiler.backend.kotlin.objc.Rendering
import com.google.j2cl.transpiler.backend.kotlin.objc.bindSource
import com.google.j2cl.transpiler.backend.kotlin.objc.classNameRendering
import com.google.j2cl.transpiler.backend.kotlin.objc.classRendering
import com.google.j2cl.transpiler.backend.kotlin.objc.combineSources
import com.google.j2cl.transpiler.backend.kotlin.objc.comment
import com.google.j2cl.transpiler.backend.kotlin.objc.dependency
import com.google.j2cl.transpiler.backend.kotlin.objc.functionDeclaration
import com.google.j2cl.transpiler.backend.kotlin.objc.idRendering
import com.google.j2cl.transpiler.backend.kotlin.objc.localImport
import com.google.j2cl.transpiler.backend.kotlin.objc.nsCopyingRendering
import com.google.j2cl.transpiler.backend.kotlin.objc.nsEnumTypedef
import com.google.j2cl.transpiler.backend.kotlin.objc.nsInlineRendering
import com.google.j2cl.transpiler.backend.kotlin.objc.nsMutableArrayRendering
import com.google.j2cl.transpiler.backend.kotlin.objc.nsMutableDictionaryRendering
import com.google.j2cl.transpiler.backend.kotlin.objc.nsMutableSetRendering
import com.google.j2cl.transpiler.backend.kotlin.objc.nsNumberRendering
import com.google.j2cl.transpiler.backend.kotlin.objc.nsObjectRendering
import com.google.j2cl.transpiler.backend.kotlin.objc.nsStringRendering
import com.google.j2cl.transpiler.backend.kotlin.objc.nsUIntegerRendering
import com.google.j2cl.transpiler.backend.kotlin.objc.orEmpty
import com.google.j2cl.transpiler.backend.kotlin.objc.protocolNameRendering
import com.google.j2cl.transpiler.backend.kotlin.objc.rendering
import com.google.j2cl.transpiler.backend.kotlin.objc.renderingWith
import com.google.j2cl.transpiler.backend.kotlin.objc.returnStatement
import com.google.j2cl.transpiler.backend.kotlin.objc.sourceWithDependencies
import com.google.j2cl.transpiler.backend.kotlin.source.dotSeparated
import com.google.j2cl.transpiler.backend.kotlin.source.emptyLineSeparated
import com.google.j2cl.transpiler.backend.kotlin.source.ifNotEmpty
import com.google.j2cl.transpiler.backend.kotlin.source.inAngleBrackets
import com.google.j2cl.transpiler.backend.kotlin.source.join
import com.google.j2cl.transpiler.backend.kotlin.source.plusNewLine
import com.google.j2cl.transpiler.backend.kotlin.source.source
import com.google.j2cl.transpiler.backend.kotlin.source.spaceSeparated

internal val CompilationUnit.j2ObjCCompatHeaderSource
  get() =
    dependenciesAndDeclarationsSource.ifNotEmpty {
      emptyLineSeparated(fileCommentSource, it).plusNewLine
    }

private val CompilationUnit.fileCommentSource
  get() = comment(source("Generated by J2KT from \"${packageRelativePath}\""))

private val CompilationUnit.dependenciesAndDeclarationsSource
  get() = declarationsRendering.sourceWithDependencies

private val CompilationUnit.declarationsRendering
  get() = declarationsRenderings.combineSources(::emptyLineSeparated)

private val CompilationUnit.declarationsRenderings
  get() = types.flatMap { it.declarationsRenderings }

private val Type.declarationsRenderings
  get() =
    buildList<Rendering> {
      if (visibility.isPrivate || declaration.isKtNative) {
        return@buildList
      }

      if (isEnum) {
        add(nsEnumTypedefRendering)
        addAll(enumGetFunctionRenderings)
      }

      addAll(methods.map { it.functionRendering })
    }

private val Type.nsEnumTypedefRendering
  get() =
    nsEnumTypedef(
      name = declaration.objCEnumName,
      type = nsUIntegerRendering,
      values = enumFields.map { it.descriptor.objCEnumName }
    )

private val Type.enumGetFunctionRenderings
  get() = enumFields.map { it.descriptor.enumGetFunctionRendering }

private val FieldDescriptor.enumGetFunctionRendering
  get() =
    functionDeclaration(
      modifiers = listOf(nsInlineRendering),
      returnType = enclosingTypeDescriptor.objCRendering,
      name = enumGetFunctionName,
      parameters = listOf(),
      statements = listOf(returnStatement(enumGetExpressionRendering))
    )

private val FieldDescriptor.enumGetFunctionName
  get() = enclosingTypeDescriptor.typeDeclaration.objCName(forMember = true) + "_get_" + name!!

private val FieldDescriptor.enumObjCName
  get() = CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, name!!)

private val FieldDescriptor.enumGetExpressionRendering
  get() =
    enclosingTypeDescriptor.typeDeclaration.objCNameRendering.bindSource { enumClassSource ->
      rendering(dotSeparated(enumClassSource, source(enumObjCName)))
    }

private val Method.functionRendering
  get() =
    takeIf { it.isStatic && !it.isConstructor }
      ?.toObjCNames()
      ?.let { functionRendering(it) }
      .orEmpty

private fun Method.functionRendering(objCNames: MethodObjCNames) =
  functionDeclaration(
    modifiers = listOf(nsInlineRendering),
    returnType = descriptor.returnTypeDescriptor.objCRendering,
    name = descriptor.functionName(objCNames),
    parameters = parameters.map { it.rendering },
    statements = statementRenderings
  )

private fun MethodDescriptor.functionName(objCNames: MethodObjCNames) =
  enclosingTypeDescriptor
    .objCName(useId = true, forMember = true)
    .plus("_")
    .plus(objCNames.methodName ?: ktName)
    .letIf(objCNames.parameterNames.isNotEmpty()) {
      it.plus("_").plus(objCNames.parameterNames.map { it + "_" }.joinToString(""))
    }

private val Method.statementRenderings
  get() =
    if (isPrimitiveVoid(descriptor.returnTypeDescriptor)) listOf()
    else listOf(returnStatement(rendering(source("0"))))

private val Variable.rendering
  get() =
    typeDescriptor.objCRendering.bindSource { typeSource ->
      rendering(spaceSeparated(typeSource, source(name.objCName)))
    }

private val TypeDeclaration.objCNameRendering
  get() = objectiveCNameRendering ?: mappedObjCNameRendering ?: defaultObjCNameRendering

private val TypeDeclaration.objectiveCNameRendering
  get() =
    objectiveCName?.let { if (isInterface) protocolNameRendering(it) else classNameRendering(it) }

private val TypeDeclaration.mappedObjCNameRendering
  get() =
    when (qualifiedBinaryName) {
      "java.lang.Object" -> nsObjectRendering
      "java.lang.String" -> nsStringRendering
      "java.lang.Class" -> classRendering
      "java.lang.Number" -> nsNumberRendering
      "java.lang.Cloneable" -> nsCopyingRendering
      "java.util.List" -> nsMutableArrayRendering
      "java.util.Set" -> nsMutableSetRendering
      "java.util.Map" -> nsMutableDictionaryRendering
      else -> null
    }

private val TypeDeclaration.defaultObjCNameRendering
  get() =
    defaultObjCName(forMember = false).let {
      if (isInterface) protocolNameRendering(it) else classNameRendering(it)
    }

private val TypeDescriptor.objCRendering
  get() =
    when (this) {
      is PrimitiveTypeDescriptor -> primitiveObjCRendering
      is DeclaredTypeDescriptor -> declaredObjCRendering
      // TODO: Handle TypeVariable and Array
      else -> idRendering
    }

private val PrimitiveTypeDescriptor.primitiveObjCRendering
  get() =
    when (this) {
      PrimitiveTypes.VOID -> rendering(source("void"))
      else -> source("j$simpleSourceName") renderingWith dependency(j2ObjCTypesImport)
    }

private val DeclaredTypeDescriptor.declaredObjCRendering
  get() =
    when {
      isJavaLangObject(this) -> idRendering
      isInterface ->
        typeDeclaration.objCNameRendering.bindSource {
          rendering(join(source("id"), inAngleBrackets(it)))
        }
      else ->
        typeDeclaration.objCNameRendering.bindSource { rendering(spaceSeparated(it, source("*"))) }
    }

private val j2ObjCTypesImport
  get() = localImport("third_party/java_src/j2objc/jre_emul/Classes/J2ObjC_types.h")

internal val TypeDeclaration.objCEnumName
  get() = "${objCName}_Enum"

internal val FieldDescriptor.objCEnumName
  get() = "${enclosingTypeDescriptor.typeDeclaration.objCEnumName}_$name"
