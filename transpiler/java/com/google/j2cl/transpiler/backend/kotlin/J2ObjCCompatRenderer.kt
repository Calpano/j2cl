/*
 * Copyright 2023 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package com.google.j2cl.transpiler.backend.kotlin

import com.google.j2cl.transpiler.ast.ArrayTypeDescriptor
import com.google.j2cl.transpiler.ast.CompilationUnit
import com.google.j2cl.transpiler.ast.DeclaredTypeDescriptor
import com.google.j2cl.transpiler.ast.Field
import com.google.j2cl.transpiler.ast.FieldDescriptor
import com.google.j2cl.transpiler.ast.Member
import com.google.j2cl.transpiler.ast.Method
import com.google.j2cl.transpiler.ast.MethodDescriptor
import com.google.j2cl.transpiler.ast.PrimitiveTypeDescriptor
import com.google.j2cl.transpiler.ast.PrimitiveTypes
import com.google.j2cl.transpiler.ast.Type
import com.google.j2cl.transpiler.ast.TypeDeclaration
import com.google.j2cl.transpiler.ast.TypeDescriptor
import com.google.j2cl.transpiler.ast.TypeDescriptors
import com.google.j2cl.transpiler.ast.TypeDescriptors.isJavaLangObject
import com.google.j2cl.transpiler.ast.TypeDescriptors.isPrimitiveVoid
import com.google.j2cl.transpiler.ast.Variable
import com.google.j2cl.transpiler.backend.kotlin.common.buildList
import com.google.j2cl.transpiler.backend.kotlin.common.camelCaseStartsWith
import com.google.j2cl.transpiler.backend.kotlin.common.letIf
import com.google.j2cl.transpiler.backend.kotlin.objc.Import
import com.google.j2cl.transpiler.backend.kotlin.objc.Renderer
import com.google.j2cl.transpiler.backend.kotlin.objc.className
import com.google.j2cl.transpiler.backend.kotlin.objc.comment
import com.google.j2cl.transpiler.backend.kotlin.objc.companionGet
import com.google.j2cl.transpiler.backend.kotlin.objc.dependency
import com.google.j2cl.transpiler.backend.kotlin.objc.empty
import com.google.j2cl.transpiler.backend.kotlin.objc.expressionStatement
import com.google.j2cl.transpiler.backend.kotlin.objc.flatten
import com.google.j2cl.transpiler.backend.kotlin.objc.functionDeclaration
import com.google.j2cl.transpiler.backend.kotlin.objc.id
import com.google.j2cl.transpiler.backend.kotlin.objc.localImport
import com.google.j2cl.transpiler.backend.kotlin.objc.map
import com.google.j2cl.transpiler.backend.kotlin.objc.map2
import com.google.j2cl.transpiler.backend.kotlin.objc.methodCall
import com.google.j2cl.transpiler.backend.kotlin.objc.nsCopying
import com.google.j2cl.transpiler.backend.kotlin.objc.nsEnumTypedef
import com.google.j2cl.transpiler.backend.kotlin.objc.nsInline
import com.google.j2cl.transpiler.backend.kotlin.objc.nsMutableArray
import com.google.j2cl.transpiler.backend.kotlin.objc.nsMutableDictionary
import com.google.j2cl.transpiler.backend.kotlin.objc.nsMutableSet
import com.google.j2cl.transpiler.backend.kotlin.objc.nsNumber
import com.google.j2cl.transpiler.backend.kotlin.objc.nsObject
import com.google.j2cl.transpiler.backend.kotlin.objc.nsString
import com.google.j2cl.transpiler.backend.kotlin.objc.nsUInteger
import com.google.j2cl.transpiler.backend.kotlin.objc.pointer
import com.google.j2cl.transpiler.backend.kotlin.objc.protocolName
import com.google.j2cl.transpiler.backend.kotlin.objc.rendererOf
import com.google.j2cl.transpiler.backend.kotlin.objc.rendererWith
import com.google.j2cl.transpiler.backend.kotlin.objc.returnStatement
import com.google.j2cl.transpiler.backend.kotlin.objc.sourceWithDependencies
import com.google.j2cl.transpiler.backend.kotlin.source.Source
import com.google.j2cl.transpiler.backend.kotlin.source.dotSeparated
import com.google.j2cl.transpiler.backend.kotlin.source.emptyLineSeparated
import com.google.j2cl.transpiler.backend.kotlin.source.ifNotEmpty
import com.google.j2cl.transpiler.backend.kotlin.source.inAngleBrackets
import com.google.j2cl.transpiler.backend.kotlin.source.join
import com.google.j2cl.transpiler.backend.kotlin.source.plusNewLine
import com.google.j2cl.transpiler.backend.kotlin.source.source
import com.google.j2cl.transpiler.backend.kotlin.source.spaceSeparated
import java.util.stream.Collectors.toList

internal val CompilationUnit.j2ObjCCompatHeaderSource: Source
  get() =
    dependenciesAndDeclarationsSource.ifNotEmpty {
      emptyLineSeparated(fileCommentSource, it).plusNewLine
    }

private val CompilationUnit.fileCommentSource: Source
  get() = comment(source("Generated by J2KT from \"${packageRelativePath}\""))

private val CompilationUnit.dependenciesAndDeclarationsSource: Source
  get() = declarationsRenderer.sourceWithDependencies

private val CompilationUnit.declarationsRenderer: Renderer<Source>
  get() = declarationsRenderers.flatten.map(::emptyLineSeparated)

private val CompilationUnit.declarationsRenderers: List<Renderer<Source>>
  get() = allTypes.filter { it.shouldRender }.flatMap(Type::declarationsRenderers)

private val CompilationUnit.allTypes: List<Type>
  get() = streamTypes().collect(toList())

private val Type.shouldRender: Boolean
  get() = visibility.isPublic && !declaration.isKtNative && !declaration.isLocal

private val Type.declarationsRenderers: List<Renderer<Source>>
  get() =
    buildList<Renderer<Source>> {
      if (isEnum) {
        add(nsEnumTypedefRenderer)
      }

      addAll(members.map { it.functionRenderer })
    }

private val Type.nsEnumTypedefRenderer: Renderer<Source>
  get() =
    nsEnumTypedef(
      name = declaration.objCEnumName,
      type = nsUInteger,
      values = enumFields.map { it.descriptor.objCEnumName }
    )

private val Field.fieldGetFunctionRenderer: Renderer<Source>
  get() = descriptor.takeIf { it.shouldRender }?.getFunctionRenderer ?: empty

private val FieldDescriptor.getFunctionRenderer: Renderer<Source>
  get() =
    functionDeclaration(
      modifiers = listOf(nsInline),
      returnType = typeDescriptor.objCRenderer,
      name = getFunctionName,
      statements = listOf(returnStatement(getExpressionRenderer))
    )

private val FieldDescriptor.getFunctionName: String
  get() = enclosingTypeDescriptor.typeDeclaration.objCName(forMember = true) + "_get_" + name!!

// Taken from GitHub:
// "JetBrains/kotlin-native/backend.native/compiler/ir/backend.native/src/org/jetbrains/kotlin/backend/konan/objcexport/ObjCExportNamer.kt"
internal val objCReservedPrefixes = setOf("alloc", "copy", "mutableCopy", "new", "init")

// Taken from GitHub:
// "JetBrains/kotlin-native/backend.native/compiler/ir/backend.native/src/org/jetbrains/kotlin/backend/konan/CAdapterGenerator.kt"
internal val cKeywords =
  setOf(
    // Actual C keywords.
    "auto",
    "break",
    "case",
    "char",
    "const",
    "continue",
    "default",
    "do",
    "double",
    "else",
    "enum",
    "extern",
    "float",
    "for",
    "goto",
    "if",
    "int",
    "long",
    "register",
    "return",
    "short",
    "signed",
    "sizeof",
    "static",
    "struct",
    "switch",
    "typedef",
    "union",
    "unsigned",
    "void",
    "volatile",
    "while",
    // C99-specific.
    "_Bool",
    "_Complex",
    "_Imaginary",
    "inline",
    "restrict",
    // C11-specific.
    "_Alignas",
    "_Alignof",
    "_Atomic",
    "_Generic",
    "_Noreturn",
    "_Static_assert",
    "_Thread_local",
    // Not exactly keywords, but reserved or standard-defined.
    "and",
    "not",
    "or",
    "xor",
    "bool",
    "complex",
    "imaginary",

    // C++ keywords not listed above.
    "alignas",
    "alignof",
    "and_eq",
    "asm",
    "bitand",
    "bitor",
    "bool",
    "catch",
    "char16_t",
    "char32_t",
    "class",
    "compl",
    "constexpr",
    "const_cast",
    "decltype",
    "delete",
    "dynamic_cast",
    "explicit",
    "export",
    "false",
    "friend",
    "inline",
    "mutable",
    "namespace",
    "new",
    "noexcept",
    "not_eq",
    "nullptr",
    "operator",
    "or_eq",
    "private",
    "protected",
    "public",
    "reinterpret_cast",
    "static_assert",
    "template",
    "this",
    "thread_local",
    "throw",
    "true",
    "try",
    "typeid",
    "typename",
    "using",
    "virtual",
    "wchar_t",
    "xor_eq"
  )

private val FieldDescriptor.getObjCName: String
  get() =
    objCName.let { name ->
      if (objCReservedPrefixes.any { name.camelCaseStartsWith(it) }) "the" + name.titleCase
      else if (cKeywords.contains(name)) name + "_" else name
    }

private val FieldDescriptor.getExpressionRenderer: Renderer<Source>
  get() =
    enclosingTypeDescriptor.typeDeclaration.objCNameRenderer
      .letIf(isStatic && !isEnumConstant) { companionGet(it) }
      .map { dotSeparated(it, source(getObjCName)) }

private val Member.functionRenderer: Renderer<Source>
  get() =
    when (this) {
      is Method -> methodFunctionRenderer
      is Field -> fieldGetFunctionRenderer
      else -> empty
    }

private val Method.methodFunctionRenderer: Renderer<Source>
  get() = takeIf { it.descriptor.shouldRender }?.toObjCNames()?.let(::functionRenderer) ?: empty

private val MethodDescriptor.shouldRender: Boolean
  get() =
    (enclosingTypeDescriptor.isClass || enclosingTypeDescriptor.isEnum) &&
      visibility.isPublic &&
      isStatic &&
      !isConstructor &&
      returnTypeDescriptor.existsInObjC &&
      parameterTypeDescriptors.all { it.existsInObjC }

private val FieldDescriptor.shouldRender: Boolean
  get() =
    (enclosingTypeDescriptor.isClass || enclosingTypeDescriptor.isEnum) &&
      visibility.isPublic &&
      isStatic &&
      typeDescriptor.existsInObjC

private val TypeDescriptor.existsInObjC: Boolean
  get() =
    when (this) {
      is DeclaredTypeDescriptor ->
        (!typeDeclaration.isKtNative || typeDeclaration.mappedObjCNameRenderer != null) &&
          !isAssignableTo(TypeDescriptors.get().javaUtilCollection) &&
          !isAssignableTo(TypeDescriptors.get().javaUtilMap)
      is ArrayTypeDescriptor -> false
      else -> true
    }

private fun Method.functionRenderer(objCNames: MethodObjCNames): Renderer<Source> =
  functionDeclaration(
    modifiers = listOf(nsInline),
    returnType = descriptor.returnTypeDescriptor.objCRenderer,
    name = descriptor.functionName(objCNames),
    parameters = parameters.map { it.renderer },
    statements = statementRenderers(objCNames)
  )

private fun MethodDescriptor.functionName(objCNames: MethodObjCNames): String =
  enclosingTypeDescriptor
    .objCName(useId = true, forMember = true)
    .plus("_")
    .plus(objCNames.methodName ?: ktName)
    .letIf(objCNames.parameterNames.isNotEmpty()) { parameterName ->
      parameterName.plus(
        objCNames.parameterNames
          .mapIndexed { index, name -> name.letIf(index == 0) { it.titleCase } + "_" }
          .joinToString("")
      )
    }

private fun Method.statementRenderers(objCNames: MethodObjCNames): List<Renderer<Source>> =
  if (isPrimitiveVoid(descriptor.returnTypeDescriptor))
    listOf(expressionStatement(methodCallRenderer(objCNames)))
  else listOf(returnStatement(methodCallRenderer(objCNames)))

private fun Method.methodCallRenderer(objCNames: MethodObjCNames): Renderer<Source> =
  methodCall(
    target = descriptor.enclosingTypeDescriptor.typeDeclaration.companionRenderer,
    name = objCNames.objCName(descriptor.ktName),
    arguments = parameters.map { it.nameRenderer }
  )

private fun MethodObjCNames.objCName(defaultMethodName: String) =
  (methodName ?: defaultMethodName)
    .plus(
      parameterNames
        .mapIndexed { index, name -> name.letIf(index == 0) { it.titleCase } + ":" }
        .joinToString("")
    )
    .run { letIf(objCReservedPrefixes.any { camelCaseStartsWith(it) }) { "do$titleCase" } }

private val Variable.renderer: Renderer<Source>
  get() =
    map2(typeDescriptor.objCRenderer, nameRenderer) { typeSource, nameSource ->
      spaceSeparated(typeSource, nameSource)
    }

private val Variable.nameRenderer: Renderer<Source>
  get() = rendererOf(source(name.objCName.run { letIf(cKeywords.contains(this)) { plus("_") } }))

private val TypeDeclaration.companionRenderer: Renderer<Source>
  get() = companionGet(objCNameRenderer)

private val TypeDeclaration.objCNameRenderer: Renderer<Source>
  get() = objectiveCNameRenderer ?: mappedObjCNameRenderer ?: defaultObjCNameRenderer

private val TypeDeclaration.objectiveCNameRenderer: Renderer<Source>?
  get() = objectiveCName?.let { if (isInterface) protocolName(it) else className(it) }

private val TypeDeclaration.mappedObjCNameRenderer: Renderer<Source>?
  get() =
    when (qualifiedBinaryName) {
      "java.lang.Object" -> nsObject
      "java.lang.String" -> nsString
      "java.lang.Number" -> nsNumber
      "java.lang.Cloneable" -> nsCopying
      "java.util.List" -> nsMutableArray
      "java.util.Set" -> nsMutableSet
      "java.util.Map" -> nsMutableDictionary
      else -> null
    }

private val TypeDeclaration.defaultObjCNameRenderer: Renderer<Source>
  get() =
    defaultObjCName(forMember = false).let { if (isInterface) protocolName(it) else className(it) }

private val TypeDescriptor.objCRenderer: Renderer<Source>
  get() =
    when (this) {
      is PrimitiveTypeDescriptor -> primitiveObjCRenderer
      is DeclaredTypeDescriptor -> declaredObjCRenderer
      // TODO: Handle TypeVariable and Array
      else -> id
    }

private val PrimitiveTypeDescriptor.primitiveObjCRenderer: Renderer<Source>
  get() =
    when (this) {
      PrimitiveTypes.VOID -> rendererOf(source("void"))
      else -> source("j$simpleSourceName") rendererWith dependency(j2ObjCTypesImport)
    }

private val DeclaredTypeDescriptor.declaredObjCRenderer: Renderer<Source>
  get() =
    when {
      isJavaLangObject(this) -> id
      isInterface -> interfaceObjCRenderer
      else -> typeDeclaration.objCNameRenderer.map(::pointer)
    }

private val DeclaredTypeDescriptor.interfaceObjCRenderer: Renderer<Source>
  get() =
    map2(id, typeDeclaration.objCNameRenderer) { idSource, typeSource ->
      join(idSource, inAngleBrackets(typeSource))
    }

private val j2ObjCTypesImport: Import
  get() = localImport("third_party/java_src/j2objc/jre_emul/Classes/J2ObjC_types.h")

private val TypeDeclaration.objCEnumName: String
  get() = "${objCName}_Enum"

private val FieldDescriptor.objCEnumName: String
  get() = "${enclosingTypeDescriptor.typeDeclaration.objCEnumName}_$name"
