/*
 * Copyright 2023 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package com.google.j2cl.transpiler.backend.kotlin

import com.google.common.base.CaseFormat
import com.google.j2cl.transpiler.ast.CompilationUnit
import com.google.j2cl.transpiler.ast.DeclaredTypeDescriptor
import com.google.j2cl.transpiler.ast.FieldDescriptor
import com.google.j2cl.transpiler.ast.Method
import com.google.j2cl.transpiler.ast.MethodDescriptor
import com.google.j2cl.transpiler.ast.PrimitiveTypeDescriptor
import com.google.j2cl.transpiler.ast.PrimitiveTypes
import com.google.j2cl.transpiler.ast.Type
import com.google.j2cl.transpiler.ast.TypeDeclaration
import com.google.j2cl.transpiler.ast.TypeDescriptor
import com.google.j2cl.transpiler.ast.TypeDescriptors.isJavaLangObject
import com.google.j2cl.transpiler.ast.TypeDescriptors.isPrimitiveVoid
import com.google.j2cl.transpiler.ast.Variable
import com.google.j2cl.transpiler.backend.kotlin.common.buildList
import com.google.j2cl.transpiler.backend.kotlin.common.letIf
import com.google.j2cl.transpiler.backend.kotlin.objc.Import
import com.google.j2cl.transpiler.backend.kotlin.objc.Renderer
import com.google.j2cl.transpiler.backend.kotlin.objc.className
import com.google.j2cl.transpiler.backend.kotlin.objc.comment
import com.google.j2cl.transpiler.backend.kotlin.objc.dependency
import com.google.j2cl.transpiler.backend.kotlin.objc.empty
import com.google.j2cl.transpiler.backend.kotlin.objc.flatten
import com.google.j2cl.transpiler.backend.kotlin.objc.functionDeclaration
import com.google.j2cl.transpiler.backend.kotlin.objc.id
import com.google.j2cl.transpiler.backend.kotlin.objc.localImport
import com.google.j2cl.transpiler.backend.kotlin.objc.map
import com.google.j2cl.transpiler.backend.kotlin.objc.nsCopying
import com.google.j2cl.transpiler.backend.kotlin.objc.nsEnumTypedef
import com.google.j2cl.transpiler.backend.kotlin.objc.nsInline
import com.google.j2cl.transpiler.backend.kotlin.objc.nsMutableArray
import com.google.j2cl.transpiler.backend.kotlin.objc.nsMutableDictionary
import com.google.j2cl.transpiler.backend.kotlin.objc.nsMutableSet
import com.google.j2cl.transpiler.backend.kotlin.objc.nsNumber
import com.google.j2cl.transpiler.backend.kotlin.objc.nsObject
import com.google.j2cl.transpiler.backend.kotlin.objc.nsString
import com.google.j2cl.transpiler.backend.kotlin.objc.nsUInteger
import com.google.j2cl.transpiler.backend.kotlin.objc.protocolName
import com.google.j2cl.transpiler.backend.kotlin.objc.rendererOf
import com.google.j2cl.transpiler.backend.kotlin.objc.rendererWith
import com.google.j2cl.transpiler.backend.kotlin.objc.returnStatement
import com.google.j2cl.transpiler.backend.kotlin.objc.sourceWithDependencies
import com.google.j2cl.transpiler.backend.kotlin.source.Source
import com.google.j2cl.transpiler.backend.kotlin.source.dotSeparated
import com.google.j2cl.transpiler.backend.kotlin.source.emptyLineSeparated
import com.google.j2cl.transpiler.backend.kotlin.source.ifNotEmpty
import com.google.j2cl.transpiler.backend.kotlin.source.inAngleBrackets
import com.google.j2cl.transpiler.backend.kotlin.source.join
import com.google.j2cl.transpiler.backend.kotlin.source.plusNewLine
import com.google.j2cl.transpiler.backend.kotlin.source.source
import com.google.j2cl.transpiler.backend.kotlin.source.spaceSeparated

internal val CompilationUnit.j2ObjCCompatHeaderSource: Source
  get() =
    dependenciesAndDeclarationsSource.ifNotEmpty {
      emptyLineSeparated(fileCommentSource, it).plusNewLine
    }

private val CompilationUnit.fileCommentSource: Source
  get() = comment(source("Generated by J2KT from \"${packageRelativePath}\""))

private val CompilationUnit.dependenciesAndDeclarationsSource: Source
  get() = declarationsRenderer.sourceWithDependencies

private val CompilationUnit.declarationsRenderer: Renderer<Source>
  get() = declarationsRenderers.flatten.map(::emptyLineSeparated)

private val CompilationUnit.declarationsRenderers: List<Renderer<Source>>
  get() = types.flatMap { it.declarationsRenderers }

private val Type.declarationsRenderers: List<Renderer<Source>>
  get() =
    buildList<Renderer<Source>> {
      if (visibility.isPrivate || declaration.isKtNative) {
        return@buildList
      }

      if (isEnum) {
        add(nsEnumTypedefRenderer)
        addAll(enumGetFunctionRenderers)
      }

      addAll(methods.map { it.functionRenderer })
    }

private val Type.nsEnumTypedefRenderer: Renderer<Source>
  get() =
    nsEnumTypedef(
      name = declaration.objCEnumName,
      type = nsUInteger,
      values = enumFields.map { it.descriptor.objCEnumName }
    )

private val Type.enumGetFunctionRenderers: List<Renderer<Source>>
  get() = enumFields.map { it.descriptor.enumGetFunctionRenderer }

private val FieldDescriptor.enumGetFunctionRenderer: Renderer<Source>
  get() =
    functionDeclaration(
      modifiers = listOf(nsInline),
      returnType = enclosingTypeDescriptor.objCRenderer,
      name = enumGetFunctionName,
      statements = listOf(returnStatement(enumGetExpressionRenderer))
    )

private val FieldDescriptor.enumGetFunctionName: String
  get() = enclosingTypeDescriptor.typeDeclaration.objCName(forMember = true) + "_get_" + name!!

private val FieldDescriptor.enumObjCName: String
  get() = CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, name!!)

private val FieldDescriptor.enumGetExpressionRenderer: Renderer<Source>
  get() =
    enclosingTypeDescriptor.typeDeclaration.objCNameRenderer.map {
      dotSeparated(it, source(enumObjCName))
    }

private val Method.functionRenderer: Renderer<Source>
  get() =
    takeIf { it.isStatic && !it.isConstructor }?.toObjCNames()?.let { functionRenderer(it) }
      ?: empty

private fun Method.functionRenderer(objCNames: MethodObjCNames): Renderer<Source> =
  functionDeclaration(
    modifiers = listOf(nsInline),
    returnType = descriptor.returnTypeDescriptor.objCRenderer,
    name = descriptor.functionName(objCNames),
    parameters = parameters.map { it.renderer },
    statements = statementRenderers
  )

private fun MethodDescriptor.functionName(objCNames: MethodObjCNames): String =
  enclosingTypeDescriptor
    .objCName(useId = true, forMember = true)
    .plus("_")
    .plus(objCNames.methodName ?: ktName)
    .letIf(objCNames.parameterNames.isNotEmpty()) {
      it.plus("_").plus(objCNames.parameterNames.map { it + "_" }.joinToString(""))
    }

private val Method.statementRenderers: List<Renderer<Source>>
  get() =
    if (isPrimitiveVoid(descriptor.returnTypeDescriptor)) listOf()
    else listOf(returnStatement(rendererOf(source("0"))))

private val Variable.renderer: Renderer<Source>
  get() = typeDescriptor.objCRenderer.map { spaceSeparated(it, source(name.objCName)) }

private val TypeDeclaration.objCNameRenderer: Renderer<Source>
  get() = objectiveCNameRenderer ?: mappedObjCNameRenderer ?: defaultObjCNameRenderer

private val TypeDeclaration.objectiveCNameRenderer: Renderer<Source>?
  get() = objectiveCName?.let { if (isInterface) protocolName(it) else className(it) }

private val TypeDeclaration.mappedObjCNameRenderer: Renderer<Source>?
  get() =
    when (qualifiedBinaryName) {
      "java.lang.Object" -> nsObject
      "java.lang.String" -> nsString
      "java.lang.Number" -> nsNumber
      "java.lang.Cloneable" -> nsCopying
      "java.util.List" -> nsMutableArray
      "java.util.Set" -> nsMutableSet
      "java.util.Map" -> nsMutableDictionary
      else -> null
    }

private val TypeDeclaration.defaultObjCNameRenderer: Renderer<Source>
  get() =
    defaultObjCName(forMember = false).let { if (isInterface) protocolName(it) else className(it) }

private val TypeDescriptor.objCRenderer: Renderer<Source>
  get() =
    when (this) {
      is PrimitiveTypeDescriptor -> primitiveObjCRenderer
      is DeclaredTypeDescriptor -> declaredObjCRenderer
      // TODO: Handle TypeVariable and Array
      else -> id
    }

private val PrimitiveTypeDescriptor.primitiveObjCRenderer: Renderer<Source>
  get() =
    when (this) {
      PrimitiveTypes.VOID -> rendererOf(source("void"))
      else -> source("j$simpleSourceName") rendererWith dependency(j2ObjCTypesImport)
    }

private val DeclaredTypeDescriptor.declaredObjCRenderer: Renderer<Source>
  get() =
    when {
      isJavaLangObject(this) -> id
      isInterface ->
        typeDeclaration.objCNameRenderer.map { join(source("id"), inAngleBrackets(it)) }
      else -> typeDeclaration.objCNameRenderer.map { spaceSeparated(it, source("*")) }
    }

private val j2ObjCTypesImport: Import
  get() = localImport("third_party/java_src/j2objc/jre_emul/Classes/J2ObjC_types.h")

private val TypeDeclaration.objCEnumName: String
  get() = "${objCName}_Enum"

private val FieldDescriptor.objCEnumName: String
  get() = "${enclosingTypeDescriptor.typeDeclaration.objCEnumName}_$name"
