// Generated from "trycatch/TryCatch.java"
package trycatch

import javaemul.lang.*
import kotlin.jvm.*

open class TryCatch {
 open fun testMultiCatch() {
  try {
   throw kotlin.ClassCastException()
  } catch (e: kotlin.NullPointerException) {
   throw e!!
  } catch (e: kotlin.ClassCastException) {
   throw e!!
  } catch (r: kotlin.RuntimeException) {
   var r_1: kotlin.RuntimeException? = r
   r_1 = null
  }
 }

 open fun testEmptyThrowableCatch() {
  try {
   throw kotlin.ClassCastException()
  } catch (e: kotlin.Throwable) {}
  try {
   throw kotlin.ClassCastException()
  } catch (e_1: kotlin.Exception) {} catch (e_2: kotlin.Throwable) {}
 }

 open fun testEmptyThrowableRethrow() {
  try {
   throw kotlin.ClassCastException()
  } catch (e: kotlin.Throwable) {
   throw e!!
  }
 }

 open fun testFinally() {
  try {
   kotlin.assert(true)
  } finally {}
 }

 open fun testTryWithResource() {
  try {
   var ___primaryExc: kotlin.Throwable? = null
   var thing: trycatch.TryCatch.ClosableThing? = null
   var thing2: trycatch.TryCatch.ClosableThing? = null
   try {
    thing = trycatch.TryCatch.ClosableThing()
    thing2 = trycatch.TryCatch.ClosableThing()
    throw kotlin.Exception()
   } catch (___exceptionFromTry: kotlin.Throwable) {
    ___primaryExc = ___exceptionFromTry
    throw ___exceptionFromTry!!
   } finally {
    ___primaryExc = javaemul.internal.Exceptions.safeClose(thing2, ___primaryExc)
    ___primaryExc = javaemul.internal.Exceptions.safeClose(thing, ___primaryExc)
    if (___primaryExc !== null) throw ___primaryExc!!
   }
  } catch (e: kotlin.Exception) {}
 }

 open fun testTryWithResourceJava9() {
  val thing: trycatch.TryCatch.ClosableThing? = trycatch.TryCatch.ClosableThing()
  val thing2: trycatch.TryCatch.ClosableThing? = trycatch.TryCatch.ClosableThing()
  try {
   var ___primaryExc: kotlin.Throwable? = null
   var ___resource: trycatch.TryCatch.ClosableThing? = null
   var ___resource_1: trycatch.TryCatch.ClosableThing? = null
   try {
    ___resource = thing
    ___resource_1 = thing2
    throw kotlin.Exception()
   } catch (___exceptionFromTry: kotlin.Throwable) {
    ___primaryExc = ___exceptionFromTry
    throw ___exceptionFromTry!!
   } finally {
    ___primaryExc = javaemul.internal.Exceptions.safeClose(___resource_1, ___primaryExc)
    ___primaryExc = javaemul.internal.Exceptions.safeClose(___resource, ___primaryExc)
    if (___primaryExc !== null) throw ___primaryExc!!
   }
  } catch (e: kotlin.Exception) {}
 }

 open fun testTryWithResouceOnStaticField() {
  try {
   var ___primaryExc: kotlin.Throwable? = null
   var ___resource: trycatch.TryCatch.ClosableThing? = null
   try {
    ___resource = trycatch.TryCatch.closableThing_private_trycatch_TryCatch
    throw kotlin.Exception()
   } catch (___exceptionFromTry: kotlin.Throwable) {
    ___primaryExc = ___exceptionFromTry
    throw ___exceptionFromTry!!
   } finally {
    ___primaryExc = javaemul.internal.Exceptions.safeClose(___resource, ___primaryExc)
    if (___primaryExc !== null) throw ___primaryExc!!
   }
  } catch (e: kotlin.Exception) {}
 }

 open fun testNestedTryCatch() {
  try {
   throw kotlin.Exception()
  } catch (ae: kotlin.Exception) {
   try {
    throw kotlin.Exception()
   } catch (ie: kotlin.Exception) {}
  }
 }

 open fun testThrowGenerics() {
  throw this.getT_private_trycatch_TryCatch<kotlin.Exception?>(kotlin.Exception())!!
 }

 fun <T> getT_private_trycatch_TryCatch(t: T): T {
  return t
 }

 open fun testThrowBoundGenerics() {
  throw this.getThrowable_private_trycatch_TryCatch<kotlin.Throwable?>()!!
 }

 fun <T: kotlin.Throwable?> getThrowable_private_trycatch_TryCatch(): T {
  return null as T
 }

 companion object {
  @kotlin.jvm.JvmField val closableThing_private_trycatch_TryCatch: trycatch.TryCatch.ClosableThing? = trycatch.TryCatch.ClosableThing()
 }

 open class ClosableThing: java.lang.AutoCloseable {
  open override fun close() {}
 }
}
