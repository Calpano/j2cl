// Generated from "typewildcards/TypeWildCards.java"
@file:OptIn(ExperimentalObjCName::class)

package typewildcards

import javaemul.lang.*
import kotlin.Any
import kotlin.Int
import kotlin.OptIn
import kotlin.String
import kotlin.experimental.ExperimentalObjCName
import kotlin.jvm.JvmField
import kotlin.jvm.JvmStatic
import kotlin.native.ObjCName
import typewildcards.Bar
import typewildcards.DeepRecursiveType
import typewildcards.Function
import typewildcards.GenericType
import typewildcards.List
import typewildcards.RecursiveSubtype
import typewildcards.RecursiveType
import typewildcards.TypeWildCards

@ObjCName("TypewildcardsFunction", exact = true)
fun interface Function<I, O> {
 fun apply(@ObjCName("withId", exact = false) i: I): O
}

@ObjCName("TypewildcardsList", exact = true)
interface List<I> {}

@ObjCName("TypewildcardsGenericType", exact = true)
open class GenericType<T> {
 open fun get(): T {
  return null as T
 }
}

@ObjCName("TypewildcardsBar", exact = true)
open class Bar {}

@ObjCName("TypewildcardsRecursiveType", exact = true)
open class RecursiveType<T: RecursiveType<T>?> {
 constructor(@ObjCName("withId", exact = false) wildcardParameter: RecursiveType<*>?)
}

@ObjCName("TypewildcardsDeepRecursiveType", exact = true)
interface DeepRecursiveType<T: GenericType<in T>?> {}

@ObjCName("TypewildcardsRecursiveSubtype", exact = true)
open class RecursiveSubtype: RecursiveType<RecursiveSubtype?> {
 constructor(@ObjCName("withId", exact = false) wildcardParameter: RecursiveType<*>?): super(wildcardParameter)
}

@ObjCName("TypewildcardsTypeWildCards", exact = true)
open class TypeWildCards {
 open fun unbounded(@ObjCName("withId", exact = false) g: GenericType<*>?): Any? {
  return g!!.get()
 }

 open fun upperBound(@ObjCName("withId", exact = false) g: GenericType<out Bar?>?): Bar? {
  return g!!.get()
 }

 open fun lowerBound(@ObjCName("withId", exact = false) g: GenericType<in Bar?>?): Any? {
  return g!!.get()
 }

 open fun unboundedRecursive(@ObjCName("withId", exact = false) g: RecursiveType<*>?) {}

 open fun upperBoundRecursive(@ObjCName("withId", exact = false) g: GenericType<out RecursiveType<*>?>?) {}

 open fun lowerBoundRecursive(@ObjCName("withId", exact = false) g: GenericType<in RecursiveType<*>?>?) {}

 open fun deepRecursiveType(@ObjCName("withId", exact = false) t: DeepRecursiveType<*>?) {}

 open fun test() {
  this.unbounded(GenericType<Bar?>() as GenericType<*>?)
  this.upperBound(GenericType<Bar?>() as GenericType<out Bar?>?)
  this.lowerBound(GenericType<Bar?>() as GenericType<in Bar?>?)
 }

 open fun testInferredGenericIntersection() {
  val elements: List<TypeWildCards.Element?>? = null
  val otherElements: List<TypeWildCards.SubOtherElement?>? = null
  val integers: List<Int?>? = TypeWildCards.transform_private_2(TypeWildCards.concat_private_2(elements, otherElements), Function { a ->
   a!!.getKey()
   return@Function a!!.get()
  })
 }

 open fun testRecursiveGeneric() {
  TypeWildCards.takesRecursiveGeneric_private_2(Foo())
 }

 companion object {
  @JvmStatic
  fun <T: TypeWildCards.A?> testBoundedTypeMemberAccess(@ObjCName("withId", exact = false) t: T) {
   val i: Int = t!!.f
   t!!.m()
  }

  @JvmStatic
  fun <T> testIntersectionBoundedTypeMemberAccess(@ObjCName("withId", exact = false) t: T) where T: TypeWildCards.A?, T: TypeWildCards.Y? {
   val i: Int = t!!.f
   t!!.m()
   t!!.n()
  }

  @JvmStatic
  fun <F, V> transform_private_2(@ObjCName("withId", exact = false) from: List<F>?, @ObjCName("withId", exact = false) function: Function<in F, out V>?): List<V>? {
   return null
  }

  @JvmStatic
  fun <E> concat_private_2(@ObjCName("withId", exact = false) a: List<out E>?, @ObjCName("withId", exact = false) b: List<out E>?): List<E>? {
   return null
  }

  @JvmStatic
  fun takesRecursiveGeneric_private_2(@ObjCName("withId", exact = false) foo: GenericType<TypeWildCards.Foo?>?) {}

  @JvmStatic
  fun <C> testInferredIntersectionWithTypeVariable(@ObjCName("withId", exact = false) ri: TypeWildCards.RecursiveInterface<out C, C>?): C {
   return ri!!.m()
  }

  @JvmStatic
  fun <D> createMultipleGenerics(@ObjCName("withId", exact = false) foo: List<D>?): TypeWildCards.MultipleGenerics<D, String?, List<D>?>? {
   return null
  }

  @JvmField var listWithWildcard: List<*>? = null

  @JvmField var valMultipleGenerics: TypeWildCards.MultipleGenerics<*, String?, *>? = TypeWildCards.createMultipleGenerics(TypeWildCards.listWithWildcard) as TypeWildCards.MultipleGenerics<*, String?, *>?
 }

 fun interface X {
  fun m()
 }

 fun interface Y {
  fun n()
 }

 open class A: TypeWildCards.X {
  @JvmField var f: Int = 0

  open override fun m() {}
 }

 fun interface IntegerSupplier {
  fun get(): Int?
 }

 fun interface HasKey {
  fun getKey(): String?
 }

 abstract inner class Element: TypeWildCards.HasKey, TypeWildCards.IntegerSupplier {}

 abstract inner class OtherElement: TypeWildCards.IntegerSupplier, TypeWildCards.HasKey {}

 abstract inner class SubOtherElement: TypeWildCards.HasKey, TypeWildCards.OtherElement() {}

 open inner class Foo: GenericType<TypeWildCards.Foo?>() {}

 fun interface RecursiveInterface<T: TypeWildCards.RecursiveInterface<T, C>?, C> {
  fun m(): T
 }

 open inner class MultipleGenerics<A, B, C> {}
}
