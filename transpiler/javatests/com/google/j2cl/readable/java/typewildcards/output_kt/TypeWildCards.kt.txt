// Generated from "typewildcards/TypeWildCards.java"
package typewildcards

import javaemul.lang.*
import kotlin.jvm.*

open class GenericType<T> {}

open class TypeWildCards {
 open fun unbounded(g: typewildcards.GenericType<*>?) {}

 open fun upperBound(g: typewildcards.GenericType<out typewildcards.TypeWildCards?>?) {}

 open fun lowerBound(g: typewildcards.GenericType<in typewildcards.TypeWildCards?>?) {}

 open fun test() {
  this.unbounded(typewildcards.GenericType<typewildcards.TypeWildCards?>() as typewildcards.GenericType<*>?)
  this.upperBound(typewildcards.GenericType<typewildcards.TypeWildCards?>() as typewildcards.GenericType<out typewildcards.TypeWildCards?>?)
  this.lowerBound(typewildcards.GenericType<typewildcards.TypeWildCards?>() as typewildcards.GenericType<in typewildcards.TypeWildCards?>?)
 }

 open fun testInferredGenericIntersection() {
  val elements: kotlin.collections.MutableList<typewildcards.TypeWildCards.Element?>? = null
  val otherElements: kotlin.collections.MutableList<typewildcards.TypeWildCards.SubOtherElement?>? = null
  val integers: kotlin.collections.MutableList<kotlin.Int?>? = typewildcards.TypeWildCards.transform<kotlin.Any? /* & typewildcards.TypeWildCards.HasKey? & typewildcards.TypeWildCards.IntegerSupplier? */, kotlin.Int?>(typewildcards.TypeWildCards.concat<kotlin.Any? /* & typewildcards.TypeWildCards.HasKey? & typewildcards.TypeWildCards.IntegerSupplier? */>(elements as kotlin.collections.MutableList<out kotlin.Any? /* & typewildcards.TypeWildCards.HasKey? & typewildcards.TypeWildCards.IntegerSupplier? */>?, otherElements as kotlin.collections.MutableList<out kotlin.Any? /* & typewildcards.TypeWildCards.HasKey? & typewildcards.TypeWildCards.IntegerSupplier? */>?), java.util.function.Function { a: kotlin.Any? /* & typewildcards.TypeWildCards.HasKey? & typewildcards.TypeWildCards.IntegerSupplier? */ ->
   a!!!!.getKey()
   return@Function a!!!!.get()!!
  })
 }

 open fun testRecursiveGeneric() {
  typewildcards.TypeWildCards.takesRecursiveGeneric(Foo())
 }

 companion object {
  @kotlin.jvm.JvmStatic
  fun <T: typewildcards.TypeWildCards.A?> testBoundedTypeMemberAccess(t: T) {
   val i: kotlin.Int = t!!.f
   t!!.m()
  }

  @kotlin.jvm.JvmStatic
  fun <T> testIntersectionBoundedTypeMemberAccess(t: T) where T: typewildcards.TypeWildCards.A?, T: typewildcards.TypeWildCards.Y? {
   val i: kotlin.Int = t!!.f
   t!!.m()
   t!!.n()
  }

  @kotlin.jvm.JvmStatic
  fun <F, V> transform(from: kotlin.collections.MutableList<F>?, function: java.util.function.Function<in F, out V>?): kotlin.collections.MutableList<V>? {
   return null
  }

  @kotlin.jvm.JvmStatic
  fun <E> concat(a: kotlin.collections.MutableList<out E>?, b: kotlin.collections.MutableList<out E>?): kotlin.collections.MutableList<E>? {
   return null
  }

  @kotlin.jvm.JvmStatic
  fun takesRecursiveGeneric(foo: typewildcards.GenericType<typewildcards.TypeWildCards.Foo?>?) {}

  @kotlin.jvm.JvmStatic
  fun <C> testInferredIntersectionWithTypeVariable(ri: typewildcards.TypeWildCards.RecursiveInterface<out C, C>?): C {
   return ri!!.m()
  }
 }

 fun interface X {
  fun m()
 }

 fun interface Y {
  fun n()
 }

 open class A: typewildcards.TypeWildCards.X {
  @kotlin.jvm.JvmField var f: kotlin.Int = 0

  open override fun m() {}
 }

 fun interface IntegerSupplier {
  fun get(): kotlin.Int?
 }

 fun interface HasKey {
  fun getKey(): kotlin.String?
 }

 abstract inner class Element: typewildcards.TypeWildCards.HasKey, typewildcards.TypeWildCards.IntegerSupplier {}

 abstract inner class OtherElement: typewildcards.TypeWildCards.IntegerSupplier, typewildcards.TypeWildCards.HasKey {}

 abstract inner class SubOtherElement: typewildcards.TypeWildCards.HasKey, typewildcards.TypeWildCards.OtherElement() {}

 open inner class Foo: typewildcards.GenericType<typewildcards.TypeWildCards.Foo?>() {}

 fun interface RecursiveInterface<T: typewildcards.TypeWildCards.RecursiveInterface<T, C>?, C> {
  fun m(): T
 }
}
