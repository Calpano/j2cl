package cast

open class CastPrimitives {
 open fun testPrimitiveCasts() {
  var b: Byte = 1
  var c: Char = 1
  var s: Short = 1
  var i: Int = 1
  var l: Long = 1L
  var f: Float = 1.1f
  var d: Double = 1.1
  b = b as Byte
  c = b as Char
  s = b as Short
  i = b as Int
  l = b as Long
  f = b as Float
  d = b as Double
  b = c as Byte
  c = c as Char
  s = c as Short
  i = c as Int
  l = c as Long
  f = c as Float
  d = c as Double
  b = s as Byte
  c = s as Char
  s = s as Short
  i = s as Int
  l = s as Long
  f = s as Float
  d = s as Double
  b = i as Byte
  c = i as Char
  s = i as Short
  i = i as Int
  l = i as Long
  f = i as Float
  d = i as Double
  b = l as Byte
  c = l as Char
  s = l as Short
  i = l as Int
  l = l as Long
  f = l as Float
  d = l as Double
  b = f as Byte
  c = f as Char
  s = f as Short
  i = f as Int
  l = f as Long
  f = f as Float
  d = f as Double
  b = d as Byte
  c = d as Char
  s = d as Short
  i = d as Int
  l = d as Long
  f = d as Float
  d = d as Double
 }

 open fun testReferenceToPrimitive() {
  val o: Any? = Any()
  val bool: Boolean = o as Boolean
  val b: Byte = o as Byte
  val c: Char = o as Char
  val s: Short = o as Short
  val i: Int = o as Int
  val l: Long = o as Long
  val f: Float = o as Float
  val d: Double = o as Double
 }

 open fun testUnboxAndWiden() {
  val boxedByte: Byte? = Byte.valueOf(0 as Byte)
  val s: Short = boxedByte as Short
  val i: Int = boxedByte as Int
  val l: Long = boxedByte as Long
  val f: Float = boxedByte as Float
  val d: Double = boxedByte as Double
 }

 open fun testImplicitArgumentCasts() {
  var b: Byte = 127
  var c: Char = 65535
  var s: Short = 32767
  var i: Int = 2147483647
  var l: Long = 9223372036854775807L
  var f: Float = 3.4028235E38f
  var d: Double = 1.7976931348623157E308
  cast.CastPrimitives.getShort(b as Short)
  cast.CastPrimitives.getInt(b as Int)
  cast.CastPrimitives.getLong(b as Long)
  cast.CastPrimitives.getFloat(b as Float)
  cast.CastPrimitives.getDouble(b as Double)
  cast.CastPrimitives.getFloat(l as Float)
  cast.CastPrimitives.getDouble(l as Double)
  cast.CastPrimitives.getDouble(f as Double)
  cast.CastPrimitives.IntValueHolder(b as Int)
  cast.CastPrimitives.IntValueHolder(c as Int)
  cast.CastPrimitives.IntValueHolder(s as Int)
  cast.CastPrimitives.LongValueHolder(b as Long)
  cast.CastPrimitives.LongValueHolder(c as Long)
  cast.CastPrimitives.LongValueHolder(i as Long)
 }

 open fun testImplicitLongAssignmentCasts() {
  val fbyte: Byte = 11
  val fchar: Char = 12
  val fshort: Short = 13
  val fint: Int = 14
  val flong: Long = 15L
  val ffloat: Float = 16.0f
  val fdouble: Double = 17.0
  var tlong: Long = 0L
  if (true) {
   tlong = fbyte as Long
   tlong = flong
  }
  if (true) {
   tlong = fint as Long
   tlong += fint
   tlong <<= fint
  }
  if (true) {
   tlong += fchar
   tlong += flong
   tlong += ffloat
  }
  if (true) {
   tlong = flong * fint
   tlong = flong >> fint
  }
  if (true) {
   tlong = flong + fshort
   tlong = flong + flong
  }
  if (true) {
   tlong = flong << tlong
   tlong <<= flong
  }
  if (true) {
   tlong = 0 + 1 + 2L
  }
 }

 companion object {
  @JvmStatic
  private fun getShort(value: Short): Short {
   return value
  }

  @JvmStatic
  private fun getInt(value: Int): Int {
   return value
  }

  @JvmStatic
  private fun getLong(value: Long): Long {
   return value
  }

  @JvmStatic
  private fun getFloat(value: Float): Float {
   return value
  }

  @JvmStatic
  private fun getDouble(value: Double): Double {
   return value
  }
 }
}

open class IntValueHolder {
 internal constructor(value: Int) {}
}

open class LongValueHolder {
 internal constructor(value: Long) {}
}
