package cast

open class Casts {
 open fun testCastToClass() {
  val o: Any? = Any()
  val c: cast.Casts? = o as cast.Casts?
 }

 open fun testCasToInterface() {
  val o: Any? = Any()
  val s: java.io.Serializable? = o as java.io.Serializable?
 }

 open fun testCastToBoxedType() {
  val o: Any? = Int(1)
  val b: Byte? = o as Byte?
  val d: Double? = o as Double?
  val f: Float? = o as Float?
  val i: Int? = o as Int?
  val l: Long? = o as Long?
  val s: Short? = o as Short?
  val n: Number? = o as Number?
  val c: java.lang.Character? = o as java.lang.Character?
  val bool: Boolean? = o as Boolean?
 }

 open fun testCastToArray() {
  val foo: Any? = null as Array<Any?>?
  val bar: Any? = null as Array<Array<Any?>?>?
 }

 private fun functionForInstanceofTest() {}

 open fun testCastObjectAfterInstanceOf() {
  var o: Any? = Any()
  if (o is cast.Casts) {
   val c: cast.Casts? = o as cast.Casts?
  }
  if (o is cast.Casts) {
   val cAvoidsCastsTo: cast.Casts? = o as cast.Casts?
   o = Any()
   val cNotAvoidCastsTo: cast.Casts? = o as cast.Casts?
  }
  if (o is cast.Casts) {
   val cAvoidsCastsTo: cast.Casts? = o as cast.Casts?
   o = TODO("expression.qualify needs rendering: Casts.this)")
   val cNotAvoidCastsTo: cast.Casts? = o as cast.Casts?
  }
  if (o is cast.Casts) {
   val cAvoidsCastsTo: cast.Casts? = o as cast.Casts?
   o = Any()
   val cAvoidCastsTo: cast.Casts? = o as cast.Casts?
  }
  if (o is cast.Casts) {
   val cAvoidsCastsTo: cast.Casts? = o as cast.Casts?
   this.functionForInstanceofTest()
   val cNotAvoidCastsTo: cast.Casts? = o as cast.Casts?
  }
 }

 open fun testCastFieldAfterInstanceOf() {
  var foo: cast.`Casts$Foo`? = TODO("expression.qualify needs rendering: Casts.this)")
  if (foo!!.field is cast.Casts) {
   val c: cast.Casts? = foo!!.field as cast.Casts?
  }
  if (foo!!.field is cast.Casts) {
   val cAvoidsCastsTo: cast.Casts? = foo!!.field as cast.Casts?
   foo!!.field = Any()
   val cNotAvoidCastsTo: cast.Casts? = foo!!.field as cast.Casts?
  }
  if (foo!!.field is cast.Casts) {
   val cAvoidsCastsTo: cast.Casts? = foo!!.field as cast.Casts?
   foo = TODO("expression.qualify needs rendering: Casts.this)")
   val cNotAvoidCastsTo: cast.Casts? = foo!!.field as cast.Casts?
  }
  if (foo!!.field is cast.Casts) {
   val cAvoidsCastsTo: cast.Casts? = foo!!.field as cast.Casts?
   this.functionForInstanceofTest()
   val cNotAvoidCastsTo: cast.Casts? = foo!!.field as cast.Casts?
  }
 }

 open fun testCaseMethodAfterInstanceOf() {
  val foo: cast.`Casts$Foo`? = TODO("expression.qualify needs rendering: Casts.this)")
  if (foo!!.method() is cast.Casts) {
   val cNotAvoidCastsTo: cast.Casts? = foo!!.method() as cast.Casts?
  }
 }
}

open class `Casts$Foo` {
 @JvmField val `this`: cast.Casts?

 @JvmField var field: Any? = Any()

 open fun method(): Any? {
  return Any()
 }
}
