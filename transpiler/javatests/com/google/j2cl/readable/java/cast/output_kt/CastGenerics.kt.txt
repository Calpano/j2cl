package cast

open class CastGenerics<T, E: kotlin.Number?> {
 constructor(): super()

 @JvmField internal var field: T? = null

 internal open fun method(): T? {
  return null
 }

 open fun testCastToTypeVariable() {
  val o: kotlin.Any? = (java.lang.Integer(1) as kotlin.Int)
  val e: E? = o as E?
  val t: T? = o as T?
  val es: Array<E>? = o as Array<E>?
  val ts: Array<T>? = o as Array<T>?
 }

 open fun <S, V: kotlin.Enum<V>?> testCastToMethodTypeVariable() {
  val o: kotlin.Any? = (java.lang.Integer(1) as kotlin.Int)
  val s: S? = o as S?
  var c: kotlin.Any? = o as cast.CastGenerics<S, kotlin.Number?>?
  c = o as Array<S>?
  c = o as V?
 }

 open fun <TT: kotlin.Enum<*>?> outerGenericMethod() {
  if (true) {}
 }

 open fun <EE> method(o: kotlin.Any?): EE? where EE: cast.`CastGenerics$Empty1`?, EE: cast.`CastGenerics$Empty2`<EE>? {
  if (o is cast.`CastGenerics$Empty1`) {
   return o as EE?
  }
  return null
 }

 companion object {
  @JvmStatic
  fun <T_1, U: T_1> testErasureCast() where T_1: cast.`CastGenerics$A`?, T_1: cast.`CastGenerics$B`? {
   var str: kotlin.String? = cast.CastGenerics<kotlin.String?, kotlin.Number?>().field
   str = cast.CastGenerics<kotlin.String?, kotlin.Number?>().method()
   val containerT: cast.`CastGenerics$Container`<T_1>? = null
   containerT!!.get()!!.mA()
   containerT!!.get()!!.mB()
   val containerU: cast.`CastGenerics$Container`<U>? = null
   containerU!!.get()!!.mA()
   containerU!!.get()!!.mB()
   val containerArrT: cast.`CastGenerics$Container`<Array<T_1>?>? = null
   val arrT: Array<T_1>? = containerArrT!!.get()
   arrT!![0]!!.mA()
   arrT!![0]!!.mB()
   var arrA: Array<cast.`CastGenerics$A`?>? = containerArrT!!.get()
   var arrB: Array<cast.`CastGenerics$B`?>? = containerArrT!!.get()
   val containerArrU: cast.`CastGenerics$Container`<Array<U>?>? = null
   val arrU: Array<U>? = containerArrU!!.get()
   arrU!![0]!!.mA()
   arrU!![0]!!.mB()
   arrA = containerArrU!!.get()
   arrB = containerArrU!!.get()
   val containerBase: cast.`CastGenerics$Container`<cast.`CastGenerics$BaseImplementor`?>? = null
   containerBase!!.get()!!.mA()
   containerBase!!.get()!!.mB()
   val containerImplementor: cast.`CastGenerics$Container`<cast.`CastGenerics$Implementor`?>? = null
   containerImplementor!!.get()!!.mA()
   containerImplementor!!.get()!!.mB()
  }

  @JvmStatic
  fun testCastToParamterizedType() {
   val o: kotlin.Any? = (java.lang.Integer(1) as kotlin.Int)
   var cc: cast.CastGenerics<java.lang.Error?, kotlin.Number?>? = o as cast.CastGenerics<java.lang.Error?, kotlin.Number?>?
   cc = o as cast.CastGenerics<*, *>?
  }

  @JvmStatic
  fun <T> doSomething(): cast.`CastGenerics$Foo`<T>? {
   return cast.`CastGenerics$1`<T>()
  }
 }
}

open class `CastGenerics$1`<T>: cast.`CastGenerics$Foo`<T> {
 internal constructor(): super()
}

fun interface `CastGenerics$A` {
 fun mA()
}

fun interface `CastGenerics$B` {
 fun mB()
}

abstract class `CastGenerics$BaseImplementor`: cast.`CastGenerics$A`, cast.`CastGenerics$B` {
 internal constructor(): super()
}

open class `CastGenerics$Implementor`: cast.`CastGenerics$BaseImplementor` {
 internal constructor(): super()

 open override fun mA() {}

 open override fun mB() {}
}

open class `CastGenerics$Container`<T> {
 internal constructor(): super()

 internal open fun get(): T? {
  return null
 }
}

interface `CastGenerics$Empty1` {}

interface `CastGenerics$Empty2`<TT> {}

open class `CastGenerics$Foo`<V> {
 constructor(): super()
}

open class `CastGenerics$1Nested`<SS, TT: kotlin.Enum<*>?, T, E: kotlin.Number?> {
 @JvmField val `this`: cast.CastGenerics<T, E>?

 internal constructor(`$outer_this`: cast.CastGenerics<T, E>?): super() {
  this.`this` = `$outer_this`
 }

 internal fun nestedGenericMethod(o: kotlin.Any?) {
  val t: TT? = o as TT?
 }
}
