package cast

open class CastGenerics<T, E: Number?> {
 @JvmField internal var field: T?

 internal open fun method(): T? {
  return null
 }

 open fun testCastToTypeVariable() {
  val o: Any? = Int(1)
  val e: E? = o as E?
  val t: T? = o as T?
  val es: Array<E>? = o as Array<E>?
  val ts: Array<T>? = o as Array<T>?
 }

 open fun <S, V: Enum<V>?> testCastToMethodTypeVariable() {
  val o: Any? = Int(1)
  val s: S? = o as S?
  var c: Any? = o as cast.CastGenerics<S, Number?>?
  c = o as Array<S>?
  c = o as V?
 }

 open fun <TT: Enum?> outerGenericMethod() {}

 open fun <EE> method(o: Any?): EE? where EE: cast.CastGenerics.Empty1?, EE: cast.CastGenerics.Empty2<EE>? {
  if (o is cast.CastGenerics.Empty1) {
   return o as EE?
  }
  return null
 }

 companion object {
  @JvmStatic
  fun <T, U: T> testErasureCast() where T: cast.CastGenerics.A?, T: cast.CastGenerics.B? {
   var str: String? = cast.CastGenerics<String?, Number?>().field
   str = cast.CastGenerics<String?, Number?>().method()
   val containerT: cast.CastGenerics.Container<T>? = null
   containerT!!.get()!!.mA()
   containerT!!.get()!!.mB()
   val containerU: cast.CastGenerics.Container<U>? = null
   containerU!!.get()!!.mA()
   containerU!!.get()!!.mB()
   val containerArrT: cast.CastGenerics.Container<Array<T>?>? = null
   val arrT: Array<T>? = containerArrT!!.get()
   arrT!![0]!!.mA()
   arrT!![0]!!.mB()
   var arrA: Array<cast.CastGenerics.A?>? = containerArrT!!.get()
   var arrB: Array<cast.CastGenerics.B?>? = containerArrT!!.get()
   val containerArrU: cast.CastGenerics.Container<Array<U>?>? = null
   val arrU: Array<U>? = containerArrU!!.get()
   arrU!![0]!!.mA()
   arrU!![0]!!.mB()
   arrA = containerArrU!!.get()
   arrB = containerArrU!!.get()
   val containerBase: cast.CastGenerics.Container<cast.CastGenerics.BaseImplementor?>? = null
   containerBase!!.get()!!.mA()
   containerBase!!.get()!!.mB()
   val containerImplementor: cast.CastGenerics.Container<cast.CastGenerics.Implementor?>? = null
   containerImplementor!!.get()!!.mA()
   containerImplementor!!.get()!!.mB()
  }

  @JvmStatic
  fun testCastToParamterizedType() {
   val o: Any? = Int(1)
   var cc: cast.CastGenerics<Error?, Number?>? = o as cast.CastGenerics<Error?, Number?>?
   cc = o as cast.CastGenerics?
  }

  @JvmStatic
  fun <T> doSomething(): cast.CastGenerics.Foo<T>? {
   return cast.CastGenerics.`1`<T>()
  }
 }
}

interface A {
 fun mA()
}

interface B {
 fun mB()
}

abstract class BaseImplementor: cast.CastGenerics.A, cast.CastGenerics.B {}

open class Implementor: cast.CastGenerics.BaseImplementor() {
 open fun mA() {}

 open fun mB() {}
}

open class Container<T> {
 internal open fun get(): T? {
  return null
 }
}

open class `1Nested`<SS, TT: Enum?, T, E: Number?> {
 @JvmField val `this`: cast.CastGenerics<T, E>?

 private fun nestedGenericMethod(o: Any?) {
  val t: TT? = o as TT?
 }
}

interface Empty1 {}

interface Empty2<TT> {}

open class `1`<T>: cast.CastGenerics.Foo<T> {
 internal constructor(): super() {

 }
}

open class Foo<V> {}
