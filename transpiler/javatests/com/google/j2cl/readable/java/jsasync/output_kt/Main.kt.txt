// Generated from "jsasync/Main.java"
@file:OptIn(ExperimentalObjCName::class, ExperimentalObjCRefinement::class)

package jsasync

import javaemul.lang.*
import kotlin.Int
import kotlin.OptIn
import kotlin.Unit
import kotlin.experimental.ExperimentalObjCName
import kotlin.experimental.ExperimentalObjCRefinement
import kotlin.jvm.JvmField
import kotlin.jvm.JvmStatic
import kotlin.native.HiddenFromObjC
import kotlin.native.ObjCName

@ObjCName("JsasyncMain", exact = true)
open class Main {
 @JvmField
 @HiddenFromObjC
 val x_private_2: Main.IThenable<Int?>? = Main.Promise.resolve<Int?>(Int.valueOf(10))

 @HiddenFromObjC
 open fun emptyAsyncMethod_pp_jsasync(): Main.IThenable<Unit?>? {
  return null
 }

 @HiddenFromObjC
 open fun asyncMethod_pp_jsasync(): Main.IThenable<Int?>? {
  val result: Int = Main.await_private_2<Int?>(Main.Promise.resolve<Int?>(Int.valueOf(7)))!!.toInt()
  return this.parametricAsyncMethod_pp_jsasync<Int?>(Int.valueOf(result))
 }

 @HiddenFromObjC
 open fun <T> parametricAsyncMethod_pp_jsasync(value: T): Main.IThenable<T>? {
  return Main.Promise.resolve<T>(Main.await_private_2<T>(Main.Promise.resolve<T>(value)))
 }

 @HiddenFromObjC
 open fun testAsyncLambdas_pp_jsasync() {
  val i: Main.AsyncInterface? = Main.AsyncInterface {
   return@AsyncInterface Main.Promise.resolve<Int?>(Main.await_private_2<Int?>(Main.Promise.resolve<Int?>(Int.valueOf(5))))
  }
  val o: Main.BaseInterface? = object : Main.BaseInterface {
   open override fun asyncCall(): Main.IThenable<Int?>? {
    return Main.Promise.resolve<Int?>(Main.await_private_2<Int?>(this@Main.x_private_2))
   }
  }
  val j: Main.AsyncJsFunctionInterface? = Main.AsyncJsFunctionInterface {
   return@AsyncJsFunctionInterface Main.Promise.resolve<Int?>(Main.await_private_2<Int?>(Main.Promise.resolve<Int?>(Int.valueOf(5))))
  }
  val optimizableJsFunction: Main.JsFunctionInterface? = object : Main.JsFunctionInterface {
   open override fun doSomething(): Main.IThenable<Int?>? {
    return Main.Promise.resolve<Int?>(Int.valueOf(5))
   }
  }
  val unoptimizableJsFunction: Main.JsFunctionInterface? = object : Main.JsFunctionInterface {
   open override fun doSomething(): Main.IThenable<Int?>? {
    val tmp: Main.JsFunctionInterface? = this
    return Main.Promise.resolve<Int?>(Main.await_private_2<Int?>(this@Main.x_private_2))
   }
  }
 }

 companion object {
  @JvmStatic
  @HiddenFromObjC
  fun staticAsyncMethod_pp_jsasync(): Main.IThenable<Unit?>? {
   return Main.Promise.resolve<Unit?>(Main.await_private_2<Unit?>(Main.Promise.resolve<Unit?>(null as Unit?)))
  }

  @JvmStatic
  @HiddenFromObjC
  external fun <T> await_private_2(thenable: Main.IThenable<T>?): T
 }

 fun interface BaseInterface {
  @ObjCName("asyncCall")
  fun asyncCall(): Main.IThenable<Int?>?
 }

 fun interface AsyncInterface: Main.BaseInterface {
  override fun asyncCall(): Main.IThenable<Int?>?
 }

 interface InterfaceWithAsyncDefaultMethod {
  @ObjCName("asyncCall")
  fun asyncCall(): Main.IThenable<Int?>? {
   return Main.Promise.resolve<Int?>(Main.await_private_2<Int?>(Main.Promise.resolve<Int?>(Int.valueOf(5))))
  }
 }

 fun interface JsFunctionInterface {
  @ObjCName("doSomething")
  fun doSomething(): Main.IThenable<Int?>?
 }

 fun interface AsyncJsFunctionInterface {
  @ObjCName("doSomething")
  fun doSomething(): Main.IThenable<Int?>?
 }

 @ObjCName("JsasyncMain_IThenable", exact = true)
 interface IThenable<T> {}

 open class Promise<T>: Main.IThenable<T> {
  companion object {
   @JvmStatic
   @ObjCName("resolve")
   external fun <T> resolve(
    @ObjCName("withId") value: T
   ): Main.Promise<T>?
  }
 }
}
