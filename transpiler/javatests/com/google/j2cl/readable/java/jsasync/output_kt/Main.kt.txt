package jsasync

open class Main {
 constructor(): super()

 internal val x: jsasync.`Main$IThenable`<kotlin.Int?>? = jsasync.`Main$Promise`.resolve(10)

 internal open fun emptyAsyncMethod(): jsasync.`Main$IThenable`<java.lang.Void?>? {
  return null
 }

 internal open fun asyncMethod(): jsasync.`Main$IThenable`<kotlin.Int?>? {
  val result: Int = jsasync.Main.await(jsasync.`Main$Promise`.resolve(7))!!
  return this.parametricAsyncMethod(result)
 }

 internal open fun <T> parametricAsyncMethod(value: T?): jsasync.`Main$IThenable`<T>? {
  return jsasync.`Main$Promise`.resolve(jsasync.Main.await(jsasync.`Main$Promise`.resolve(value)))
 }

 internal open fun testAsyncLambdas() {
  val i: jsasync.`Main$AsyncInterface`? = jsasync.`Main$AsyncInterface` (fun(): jsasync.`Main$IThenable`<kotlin.Int?>? {
   return jsasync.`Main$Promise`.resolve(jsasync.Main.await(jsasync.`Main$Promise`.resolve(5)))
  })
  val o: jsasync.`Main$BaseInterface`? = jsasync.`Main$1`(this)
  val j: jsasync.`Main$AsyncJsFunctionInterface`? = jsasync.`Main$AsyncJsFunctionInterface` (fun(): jsasync.`Main$IThenable`<kotlin.Int?>? {
   return jsasync.`Main$Promise`.resolve(jsasync.Main.await(jsasync.`Main$Promise`.resolve(5)))
  })
  val optimizableJsFunction: jsasync.`Main$JsFunctionInterface`? = jsasync.`Main$2`(this)
  val unoptimizableJsFunction: jsasync.`Main$JsFunctionInterface`? = jsasync.`Main$3`(this)
 }

 companion object {
  @JvmStatic
  internal fun staticAsyncMethod(): jsasync.`Main$IThenable`<java.lang.Void?>? {
   return jsasync.`Main$Promise`.resolve(jsasync.Main.await(jsasync.`Main$Promise`.resolve(null as java.lang.Void?)))
  }

  @JvmStatic
  external internal fun <T> await(thenable: jsasync.`Main$IThenable`<T>?): T?
 }
}

open class `Main$1`: jsasync.`Main$BaseInterface` {
 @JvmField val `this`: jsasync.Main?

 internal constructor(`$outer_this`: jsasync.Main?): super() {
  this.`this` = `$outer_this`
 }

 open override fun asyncCall(): jsasync.`Main$IThenable`<kotlin.Int?>? {
  return jsasync.`Main$Promise`.resolve(jsasync.Main.await(this.`this`!!.x))
 }
}

open class `Main$2`: jsasync.`Main$JsFunctionInterface` {
 @JvmField val `this`: jsasync.Main?

 internal constructor(`$outer_this`: jsasync.Main?): super() {
  this.`this` = `$outer_this`
 }

 open override fun doSomething(): jsasync.`Main$IThenable`<kotlin.Int?>? {
  return jsasync.`Main$Promise`.resolve(5)
 }
}

open class `Main$3`: jsasync.`Main$JsFunctionInterface` {
 @JvmField val `this`: jsasync.Main?

 internal constructor(`$outer_this`: jsasync.Main?): super() {
  this.`this` = `$outer_this`
 }

 open override fun doSomething(): jsasync.`Main$IThenable`<kotlin.Int?>? {
  val tmp: jsasync.`Main$JsFunctionInterface`? = this
  return jsasync.`Main$Promise`.resolve(jsasync.Main.await(this.`this`!!.x))
 }
}

fun interface `Main$BaseInterface` {
 fun asyncCall(): jsasync.`Main$IThenable`<kotlin.Int?>?
}

fun interface `Main$AsyncInterface`: jsasync.`Main$BaseInterface` {
 override fun asyncCall(): jsasync.`Main$IThenable`<kotlin.Int?>?
}

interface `Main$InterfaceWithAsyncDefaultMethod` {
 fun asyncCall(): jsasync.`Main$IThenable`<kotlin.Int?>? {
  return jsasync.`Main$Promise`.resolve(jsasync.Main.await(jsasync.`Main$Promise`.resolve(5)))
 }
}

fun interface `Main$JsFunctionInterface` {
 fun doSomething(): jsasync.`Main$IThenable`<kotlin.Int?>?
}

fun interface `Main$AsyncJsFunctionInterface` {
 fun doSomething(): jsasync.`Main$IThenable`<kotlin.Int?>?
}

interface `Main$IThenable`<T> {}

open class `Main$Promise`<T>: jsasync.`Main$IThenable`<T> {
 internal constructor(): super()

 companion object {
  @JvmStatic
  external fun <T_1> resolve(value: T_1?): jsasync.`Main$Promise`<T_1>?
 }
}
