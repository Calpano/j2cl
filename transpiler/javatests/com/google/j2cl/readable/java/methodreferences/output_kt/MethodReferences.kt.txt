package methodreferences

open class MethodReferences<T> {
 constructor(): super()

 open fun isA(): Boolean? {
  return true
 }

 internal open fun self(): Any? {
  return this
 }

 internal open fun sameAs(n: Number?): Boolean? {
  return false
 }

 internal open fun main() {
  var objectFactory: methodreferences.`MethodReferences$Producer`<Any?>? = {
   return Any()
  }
  objectFactory = {
   return methodreferences.MethodReferences.m()
  }
  objectFactory = run {
   val `$$q`: methodreferences.MethodReferences<T> = methodreferences.MethodReferences<T>()
   {
    return `$$q`.isA()
   }
  }
  val biFunction: methodreferences.`MethodReferences$BiFunction`<methodreferences.MethodReferences<T>?, Number?, Boolean?>? = { arg0: methodreferences.MethodReferences<T>?, arg1: Number? ->
   return arg0!!.sameAs(arg1)
  }
  val functionWithParameters: methodreferences.`MethodReferences$Function`<Number?, Boolean?>? = { arg0_1: Number? ->
   return this.sameAs(arg0_1)
  }
  val objectPredicate: methodreferences.`MethodReferences$Predicate`<methodreferences.MethodReferences<T>?>? = { arg0_2: methodreferences.MethodReferences<T>? ->
   return arg0_2!!.isA()!!
  }
  val objectCapturingOuterProducer: methodreferences.`MethodReferences$Producer`<methodreferences.`MethodReferences$ObjectCapturingOuter`<T>?>? = {
   return methodreferences.`MethodReferences$ObjectCapturingOuter`<T>(this)
  }
  val arrayProducer: methodreferences.`MethodReferences$ArrayProducer`<Any?>? = { arg0_3: Int ->
   return arrayOfNulls<Double?>(arg0_3)
  }
  objectFactory = run {
   val `$$q_1`: methodreferences.MethodReferences<Any?> = methodreferences.MethodReferences<Any?>()
   {
    return `$$q_1`.self()
   }
  }
  val function: methodreferences.`MethodReferences$Function`<methodreferences.MethodReferences<T>?, Any?>? = { arg0_4: methodreferences.MethodReferences<T>? ->
   return arg0_4!!.self()
  }
  val arrayFactory: methodreferences.`MethodReferences$Function`<Int?, Array<Any?>?>? = { arg0_5: Int? ->
   return arrayOfNulls<Any?>(arg0_5!!)
  }
  val superToStringProducer: methodreferences.`MethodReferences$Producer`<String?>? = {
   return this.toString()
  }
  var jsobjectFactory: methodreferences.`MethodReferences$JsProducer`<Any?>? = {
   return Any()
  }
  jsobjectFactory = {
   return methodreferences.MethodReferences.m()
  }
  jsobjectFactory = run {
   val `$$q_2`: methodreferences.MethodReferences<Any?> = methodreferences.MethodReferences<Any?>()
   {
    return `$$q_2`.self()
   }
  }
  val jsfunction: methodreferences.`MethodReferences$JsFunctionInterface`<methodreferences.MethodReferences<T>?, Any?>? = { arg0_6: methodreferences.MethodReferences<T>? ->
   return arg0_6!!.self()
  }
  val jsarrayFactory: methodreferences.`MethodReferences$JsFunctionInterface`<Int?, Array<Any?>?>? = { arg0_7: Int? ->
   return arrayOfNulls<Any?>(arg0_7!!)
  }
  val jsSuperToStringProducer: methodreferences.`MethodReferences$JsProducer`<String?>? = {
   return this.toString()
  }
  val jsbiFunction: methodreferences.`MethodReferences$JsBiFunction`<methodreferences.MethodReferences<T>?, Number?, Boolean?>? = { arg0_8: methodreferences.MethodReferences<T>?, arg1_1: Number? ->
   return arg0_8!!.sameAs(arg1_1)
  }
  val jsFunctionWithParameters: methodreferences.`MethodReferences$JsFunctionInterface`<Number?, Boolean?>? = { arg0_9: Number? ->
   return this.sameAs(arg0_9)
  }
 }

 companion object {
  @JvmStatic
  internal fun m(): Any? {
   return Any()
  }

  @JvmField internal var staticStringProducer: methodreferences.`MethodReferences$Producer`<String?>? = run {
   val `$$q`: Any? = methodreferences.MethodReferences.m()
   {
    return `$$q`!!.toString()
   }
  }
 }
}

interface `MethodReferences$Producer`<T> {
 fun produce(): T?
}

interface `MethodReferences$Predicate`<T> {
 fun apply(parameter: T?): Boolean
}

interface `MethodReferences$ArrayProducer`<T> {
 fun produce(size: Int): Array<T>?
}

open class `MethodReferences$ObjectCapturingOuter`<T> {
 internal constructor(`$outer_this`: methodreferences.MethodReferences<T>?): super() {
  this.`this` = `$outer_this`
 }

 @JvmField val `this`: methodreferences.MethodReferences<T>?

 internal open fun getMain(): methodreferences.MethodReferences<T>? {
  return this.`this`
 }
}

interface `MethodReferences$Function`<T, U> {
 fun apply(t: T?): U?
}

interface `MethodReferences$BiFunction`<T, U, V> {
 fun apply(t: T?, u: U?): V?
}

interface `MethodReferences$JsProducer`<T> {
 fun produce(): T?
}

interface `MethodReferences$JsFunctionInterface`<T, U> {
 fun apply(t: T?): U?
}

interface `MethodReferences$JsBiFunction`<T, U, V> {
 fun apply(t: T?, u: U?): V?
}
