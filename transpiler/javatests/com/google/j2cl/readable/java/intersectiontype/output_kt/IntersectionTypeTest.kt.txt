// Generated from "intersectiontype/IntersectionTypeTest.java"
package intersectiontype

import javaemul.lang.*
import kotlin.jvm.*

fun interface Getable<T> {
 fun get(): T
}

fun interface Setable {
 fun set(i: kotlin.Int)
}

interface Serial {}

fun interface Cmp {
 fun cmp(): kotlin.Int
}

fun interface Cmp2<T> {
 fun cmp(a: kotlin.Int): kotlin.Int
}

open class IntersectionTypeTest<U> {
 open fun cast3(s: kotlin.Any?): kotlin.Any? {
  return s
 }

 open fun testMethodCall() {
  val o: kotlin.Any? = intersectiontype.IntersectionTypeTest.m()
  intersectiontype.IntersectionTypeTest.set((o).let { it as intersectiontype.IntersectionTypeTest.A?; it as intersectiontype.IntersectionTypeTest.EmptyA?; it })
  intersectiontype.IntersectionTypeTest.set(intersectiontype.IntersectionTypeTest.m())
  val g: intersectiontype.Getable<*>? = intersectiontype.IntersectionTypeTest.n() as intersectiontype.Getable<*>?
 }

 companion object {
  @kotlin.jvm.JvmStatic
  fun <T> getAndSet(`object`: T) where T: intersectiontype.Getable<*>?, T: intersectiontype.Setable? {
   `object`!!.set(1)
   `object`!!.get()
  }

  @kotlin.jvm.JvmStatic
  fun <T> cast(o: kotlin.Any?): intersectiontype.Getable<T>? {
   if (o === null) {
    return (o).let { it as intersectiontype.Getable<T>?; it as intersectiontype.Setable?; it }
   }
   return (o).let { it as intersectiontype.Getable<T>?; it as intersectiontype.Setable?; it }
  }

  @kotlin.jvm.JvmStatic
  fun <T> cast1(s: kotlin.Any?): intersectiontype.Getable<kotlin.Comparable<kotlin.String>?>? {
   return (s).let { it as intersectiontype.Getable<kotlin.Comparable<kotlin.String>?>?; it as intersectiontype.Setable?; it }
  }

  @kotlin.jvm.JvmStatic
  fun <T> cast2(s: kotlin.Any?): intersectiontype.Getable<kotlin.Comparable<T>?>? {
   return (s).let { it as intersectiontype.Getable<kotlin.Comparable<T>?>?; it as intersectiontype.Setable?; it }
  }

  @kotlin.jvm.JvmStatic
  fun method(): intersectiontype.Cmp? {
   return (intersectiontype.Cmp {
    return@Cmp 1
   }).let { it as intersectiontype.Cmp?; it as intersectiontype.Serial?; it }
  }

  @kotlin.jvm.JvmStatic
  fun method2(): intersectiontype.Cmp2<kotlin.Any?>? {
   return intersectiontype.Cmp2<kotlin.Any?> { a: kotlin.Int ->
    return@Cmp2 1
   } as intersectiontype.Cmp2<kotlin.Any?>?
  }

  @kotlin.jvm.JvmStatic
  fun testClosureAssignment(o: kotlin.Any?) {
   val e: intersectiontype.IntersectionTypeTest.A? = (o).let { it as intersectiontype.IntersectionTypeTest.A?; it as intersectiontype.IntersectionTypeTest.EmptyA?; it as intersectiontype.IntersectionTypeTest.EmptyB?; it }
   val g: intersectiontype.IntersectionTypeTest.EmptyA? = (o).let { it as intersectiontype.IntersectionTypeTest.A?; it as intersectiontype.IntersectionTypeTest.EmptyA?; it as intersectiontype.IntersectionTypeTest.EmptyB?; it }
   val s: intersectiontype.IntersectionTypeTest.EmptyB? = (o).let { it as intersectiontype.IntersectionTypeTest.A?; it as intersectiontype.IntersectionTypeTest.EmptyA?; it as intersectiontype.IntersectionTypeTest.EmptyB?; it }
  }

  @kotlin.jvm.JvmStatic
  fun <T> get(t: T): T {
   return t
  }

  @kotlin.jvm.JvmStatic
  fun <T> m(): T where T: intersectiontype.IntersectionTypeTest.A?, T: intersectiontype.IntersectionTypeTest.EmptyA? {
   return intersectiontype.IntersectionTypeTest.get<kotlin.Any?>(kotlin.Any()) as T
  }

  @kotlin.jvm.JvmStatic
  fun <T> n(): intersectiontype.Getable<T>? where T: intersectiontype.IntersectionTypeTest.A?, T: intersectiontype.IntersectionTypeTest.EmptyA? {
   return null
  }

  @kotlin.jvm.JvmStatic
  fun <T> set(t: T) where T: intersectiontype.IntersectionTypeTest.A?, T: intersectiontype.IntersectionTypeTest.EmptyA? {}

  @kotlin.jvm.JvmStatic
  fun <T> callOnIntersetionTypes(t: T) where T: intersectiontype.IntersectionTypeTest.SomeConcreteType?, T: intersectiontype.Cmp? {
   t!!.cmp()
   ((null).let { it as intersectiontype.IntersectionTypeTest.SomeConcreteType?; it as intersectiontype.Cmp?; it })!!.cmp()
  }
 }

 open inner class MapEntry {
  open fun <T> method(o: kotlin.Any?): intersectiontype.Getable<T>? {
   return (o).let { it as intersectiontype.Getable<T>?; it as intersectiontype.Setable?; it }
  }
 }

 open class A {}

 interface EmptyA {}

 interface EmptyB {}

 open class SomeConcreteType {}
}
