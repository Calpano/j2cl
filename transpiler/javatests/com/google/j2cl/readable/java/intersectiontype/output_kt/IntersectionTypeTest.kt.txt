package intersectiontype

interface Getable<T> {
 fun get(): T?
}

interface Setable {
 fun set(i: Int)
}

interface Serial {}

interface Cmp {
 fun cmp(): Int
}

interface Cmp2<T> {
 fun cmp(a: Int): Int
}

open class IntersectionTypeTest<U> {
 constructor(): super()

 open fun cast3(s: Any?): Any? {
  return s
 }

 open fun testMethodCall() {
  val o: Any? = intersectiontype.IntersectionTypeTest.m()
  intersectiontype.IntersectionTypeTest.set(o as intersectiontype.`IntersectionTypeTest$A`? /* & intersectiontype.`IntersectionTypeTest$EmptyA`? */)
  intersectiontype.IntersectionTypeTest.set(intersectiontype.IntersectionTypeTest.m())
  val g: intersectiontype.Getable<*>? = intersectiontype.IntersectionTypeTest.n()
 }

 companion object {
  @JvmStatic
  fun <T> getAndSet(`object`: T?) where T: intersectiontype.Getable<*>?, T: intersectiontype.Setable? {
   `object`!!.set(1)
   `object`!!.get()
  }

  @JvmStatic
  fun <T> cast(o: Any?): intersectiontype.Getable<T>? {
   if (o === null) {
    return o as intersectiontype.Getable<T>? /* & intersectiontype.Setable? */
   }
   return o as intersectiontype.Getable<T>? /* & intersectiontype.Setable? */
  }

  @JvmStatic
  fun <T> cast1(s: Any?): intersectiontype.Getable<Comparable<String?>?>? {
   return s as intersectiontype.Getable<Comparable<String?>?>? /* & intersectiontype.Setable? */
  }

  @JvmStatic
  fun <T> cast2(s: Any?): intersectiontype.Getable<Comparable<T>?>? {
   return s as intersectiontype.Getable<Comparable<T>?>? /* & intersectiontype.Setable? */
  }

  @JvmStatic
  fun method(): intersectiontype.Cmp? {
   return {
    return 1
   } as intersectiontype.Cmp? /* & intersectiontype.Serial? */
  }

  @JvmStatic
  fun method2(): intersectiontype.Cmp2<*>? {
   return { a: Int ->
    return 1
   } as intersectiontype.Cmp2<*>? /* & intersectiontype.Serial? */
  }

  @JvmStatic
  fun testClosureAssignment(o: Any?) {
   val e: intersectiontype.`IntersectionTypeTest$A`? = o as intersectiontype.`IntersectionTypeTest$A`? /* & intersectiontype.`IntersectionTypeTest$EmptyA`? & intersectiontype.`IntersectionTypeTest$EmptyB`? */
   val g: intersectiontype.`IntersectionTypeTest$EmptyA`? = o as intersectiontype.`IntersectionTypeTest$A`? /* & intersectiontype.`IntersectionTypeTest$EmptyA`? & intersectiontype.`IntersectionTypeTest$EmptyB`? */
   val s: intersectiontype.`IntersectionTypeTest$EmptyB`? = o as intersectiontype.`IntersectionTypeTest$A`? /* & intersectiontype.`IntersectionTypeTest$EmptyA`? & intersectiontype.`IntersectionTypeTest$EmptyB`? */
  }

  @JvmStatic
  internal fun <T> get(t: T?): T? {
   return t
  }

  @JvmStatic
  internal fun <T> m(): T? where T: intersectiontype.`IntersectionTypeTest$A`?, T: intersectiontype.`IntersectionTypeTest$EmptyA`? {
   return intersectiontype.IntersectionTypeTest.get(Any()) as T?
  }

  @JvmStatic
  internal fun <T> n(): intersectiontype.Getable<T>? where T: intersectiontype.`IntersectionTypeTest$A`?, T: intersectiontype.`IntersectionTypeTest$EmptyA`? {
   return null
  }

  @JvmStatic
  internal fun <T> set(t: T?) where T: intersectiontype.`IntersectionTypeTest$A`?, T: intersectiontype.`IntersectionTypeTest$EmptyA`? {}
 }
}

open class `IntersectionTypeTest$MapEntry`<U> {
 internal constructor(`$outer_this`: intersectiontype.IntersectionTypeTest<U>?): super() {
  this.`this` = `$outer_this`
 }

 @JvmField val `this`: intersectiontype.IntersectionTypeTest<U>?

 open fun <T> method(o: Any?): intersectiontype.Getable<T>? {
  return o as intersectiontype.Getable<T>? /* & intersectiontype.Setable? */
 }
}

open class `IntersectionTypeTest$A` {
 internal constructor(): super()
}

interface `IntersectionTypeTest$EmptyA` {}

interface `IntersectionTypeTest$EmptyB` {}
