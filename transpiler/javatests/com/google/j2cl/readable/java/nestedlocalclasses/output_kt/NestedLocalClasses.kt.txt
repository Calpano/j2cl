package nestedlocalclasses

open class NestedLocalClasses {
 open fun test(p: Int) {
  var localVar: Int = 1
 }
}

open class `NestedLocalClasses$1InnerClass` {
 @JvmField val `this`: nestedlocalclasses.NestedLocalClasses?

 open fun `fun`() {
  var localVarInInnerClass: Int = 1
  TODO("expression.qualify needs rendering: \$1InnerClass.this)")
 }

 @JvmField val localVar: Int
}

open class `NestedLocalClasses$1InnerClass$1InnerInnerClass` {
 @JvmField val `this`: nestedlocalclasses.`NestedLocalClasses$1InnerClass`?

 @JvmField var fieldInInnerInnerClass: Int = this.localVar + this.localVarInInnerClass

 @JvmField val localVar: Int

 @JvmField val localVarInInnerClass: Int
}

open class `NestedLocalClasses$1InnerClass$1ClassIndirectlyCapturingLocal` {
 @JvmField val `this`: nestedlocalclasses.`NestedLocalClasses$1InnerClass`?

 init {
  TODO("expression.qualify needs rendering: \$1ClassIndirectlyCapturingLocal.this.this)")
 }

 @JvmField val localVar: Int

 @JvmField val localVarInInnerClass: Int
}

interface `NestedLocalClasses$InterfaceWithThisReference` {
 fun foo() {
  TODO("expression.qualify needs rendering: InterfaceWithThisReference.this)")
 }
}

open class `NestedLocalClasses$InterfaceWithThisReference$1Super`: nestedlocalclasses.`NestedLocalClasses$InterfaceWithThisReference` {
 @JvmField val `this`: nestedlocalclasses.`NestedLocalClasses$InterfaceWithThisReference`?
}

open class `NestedLocalClasses$InterfaceWithThisReference$1`: nestedlocalclasses.`NestedLocalClasses$InterfaceWithThisReference$1Super` {
 internal constructor(): super() {

 }

 @JvmField val `this`: nestedlocalclasses.`NestedLocalClasses$InterfaceWithThisReference`?
}
