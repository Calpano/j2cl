package nestedlocalclasses

open class NestedLocalClasses {
 open fun test(p: Int) {
  var localVar: Int = 1
 }
}

open class `1InnerClass` {
 val `this`: nestedlocalclasses.NestedLocalClasses?

 open fun `fun`() {
  var localVarInInnerClass: Int = 1
  TODO("expression.qualify needs rendering: \$1InnerClass.this)")
 }

 val localVar: Int
}

open class `1InnerInnerClass` {
 val `this`: nestedlocalclasses.NestedLocalClasses.`1InnerClass`?

 var fieldInInnerInnerClass: Int = this.localVar + this.localVarInInnerClass

 val localVar: Int

 val localVarInInnerClass: Int
}

open class `1ClassIndirectlyCapturingLocal` {
 val `this`: nestedlocalclasses.NestedLocalClasses.`1InnerClass`?

 init {
  TODO("expression.qualify needs rendering: \$1ClassIndirectlyCapturingLocal.this.this)")
 }

 val localVar: Int

 val localVarInInnerClass: Int
}

interface InterfaceWithThisReference {
 fun foo() {
  TODO("expression.qualify needs rendering: InterfaceWithThisReference.this)")
 }
}

open class `1Super`: nestedlocalclasses.NestedLocalClasses.InterfaceWithThisReference {
 val `this`: nestedlocalclasses.NestedLocalClasses.InterfaceWithThisReference?
}

open class `1`: nestedlocalclasses.NestedLocalClasses.InterfaceWithThisReference.`1Super` {
 internal constructor() {
  super()
 }

 val `this`: nestedlocalclasses.NestedLocalClasses.InterfaceWithThisReference?
}
