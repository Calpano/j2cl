package lambdas

open class Lambdas {
 constructor(): super()

 @JvmField var field: Int = 100

 open fun call(intf: lambdas.`Lambdas$FunctionalInterface`?, n: Int): Int {
  return this.field + intf!!.m(n)
 }

 open fun testLambdaExpressionStyle() {
  this.call({ i: Int ->
   return i + 1
  }, 10)
 }

 open fun testLambdaBlockStyle() {
  this.call({ i: Int ->
   return i + 2
  }, 10)
 }

 open fun testLambdaCaptureField() {
  this.call({ i: Int ->
   return this.field + i + 1
  }, 10)
 }

 open fun testLambdaCaptureLocal() {
  val x: Int = 1
  this.call({ i: Int ->
   return x + i + 1
  }, 10)
 }

 open fun testLambdaCaptureFieldAndLocal() {
  val x: Int = 1
  this.call({ i: Int ->
   val y: Int = 1
   return x + y + this.field + i + 1
  }, 10)
 }

 open fun funOuter() {}

 open fun testLambdaCallOuterFunction() {
  this.call({ i: Int ->
   this.funOuter()
   this.funOuter()
   this.funOuter()
   return i + 2
  }, 10)
 }

 open fun <T> testInstanceMethodTypeVariableThroughLambda() {
  val wrapped: lambdas.`Lambdas$Functional`<T>? = { f: lambdas.`Lambdas$Functional`<T>? ->
   return lambdas.`Lambdas$1`<T>(this)
  }
 }

 open fun <T> callWithTypeVariable(intf: lambdas.`Lambdas$GenericFunctionalInterface`<T>?, e: T?): T? {
  return intf!!.m(e)
 }

 open fun callParameterized(intf: lambdas.`Lambdas$GenericFunctionalInterface`<Error?>?, e: Error?): Error? {
  return intf!!.m(e)
 }

 internal open fun <T> callWithBiFunction(fn: lambdas.`Lambdas$BiFunction`<T, String?, Double?>?): lambdas.`Lambdas$GenericFunctionalInterface`<T>? {
  return null
 }

 open fun <T: Enum<T>?> testLambdaWithGenerics() {
  this.callWithTypeVariable({ i: Error? ->
   return i
  }, Error())
  this.callParameterized({ i_1: Error? ->
   return i_1
  }, Error())
  lambdas.Lambdas.callTypeVariableWithBounds({ i_2: Enum<T>? ->
   return i_2
  }, null as Enum<T>?)
  this.callWithBiFunction({ x: Any?, y: String? ->
   throw java.lang.RuntimeException()
  })
  val f: lambdas.`Lambdas$Function`<*, *>? = { item: T? ->
   return 1L
  }
 }

 open fun testLambdaReturningVoidAsExpression() {
  val runner: lambdas.`Lambdas$FunctionalInterfaceWithMethodReturningVoid`? = {
   Any()
  }
 }

 open fun testAnonymousInsideLambda() {
  val runner: lambdas.`Lambdas$FunctionalInterfaceWithMethodReturningVoid`? = {
   lambdas.`Lambdas$3`(this)
  }
 }

 open fun testDefaultMethodsInIntersectionAdaptor() {
  val o: Any? = { t: String?, u: String? ->
   return null
  } as lambdas.`Lambdas$BiFunction`<String?, String?, String?>? /* & lambdas.`Lambdas$MarkerWithDefaultMethod`? */
 }

 companion object {
  @JvmStatic
  fun testLambdaInStaticContext() {
   val f: lambdas.`Lambdas$FunctionalInterface`? = { i: Int ->
    return i
   }
  }

  @JvmStatic
  fun <T> testStaticMethodTypeVariableThroughLambda() {
   val wrapped: lambdas.`Lambdas$Functional`<T>? = { f: lambdas.`Lambdas$Functional`<T>? ->
    return lambdas.`Lambdas$2`<T>()
   }
  }

  @JvmStatic
  fun <T: Enum<T>?> callTypeVariableWithBounds(intf: lambdas.`Lambdas$GenericFunctionalInterface`<Enum<T>?>?, e: Enum<T>?): Enum<T>? {
   return intf!!.m(e)
  }

  @JvmStatic
  fun m(): Any? {
   return null
  }

  @JvmStatic
  fun testLambdaCallingStaticMethod() {
   val f: lambdas.`Lambdas$Function`<Any?, *>? = { l: Any? ->
    return lambdas.Lambdas.m()
   }
  }

  internal var identityFunction: lambdas.`Lambdas$IdentityFunction`? = null

  @JvmStatic
  fun <E> identity(): lambdas.`Lambdas$GenericJsFunction`<E, E>? {
   if (lambdas.Lambdas.identityFunction === null) {
    lambdas.Lambdas.identityFunction = lambdas.`Lambdas$IdentityFunction`()
   }
   return lambdas.Lambdas.identityFunction as lambdas.`Lambdas$GenericJsFunction`<E, E>?
  }

  @JvmStatic
  fun testJsInteropLambdas() {
   val thenable: lambdas.`Lambdas$Thenable`<String?>? = { f1: lambdas.`Lambdas$GenericJsFunction`<java.lang.Void?, String?>?, f2: lambdas.`Lambdas$GenericJsFunction`<java.lang.Void?, Throwable?>? ->
    f1!!.apply(null)
   }
   val otherThenable: lambdas.`Lambdas$AnotherThenable`<String?>? = { f1_1: lambdas.`Lambdas$GenericJsFunction`<java.lang.Void?, String?>?, f2_1: lambdas.`Lambdas$GenericJsFunction`<java.lang.Void?, Throwable?>? ->
    f1_1!!.apply(null)
   }
   val stringJsSupplier: lambdas.`Lambdas$JsSupplier`<Int?>? = {
    return 1
   }
   stringJsSupplier!!.get()
   val equals: lambdas.`Lambdas$Equals`<*>? = stringJsSupplier
   equals!!.equals(null)
   equals!!.get()
  }

  @JvmStatic
  fun <U, V> testIntersectionTyping() {
   var o: Any? = { x: String? ->
    return x
   } as lambdas.`Lambdas$GenericFunctionalInterface`<String?>? /* & lambdas.`Lambdas$JustADefaultT`<Number?>? */
   o = { x_1: String? ->
    return x_1
   } as lambdas.`Lambdas$GenericFunctionalInterface`<String?>? /* & lambdas.`Lambdas$JustADefaultS`<Number?>? */
   o = { x_2: U? ->
    return x_2
   } as lambdas.`Lambdas$GenericFunctionalInterface`<U>? /* & lambdas.`Lambdas$JustADefaultS`<V>? */
  }
 }
}

interface `Lambdas$FunctionalInterface` {
 fun m(i: Int): Int
}

interface `Lambdas$Functional`<T> {
 fun wrap(f: lambdas.`Lambdas$Functional`<T>?): lambdas.`Lambdas$Functional`<T>?
}

open class `Lambdas$1`<T>: lambdas.`Lambdas$Functional`<T> {
 internal constructor(`$outer_this`: lambdas.Lambdas?): super() {
  this.`this` = `$outer_this`
 }

 @JvmField val `this`: lambdas.Lambdas?

 open override fun wrap(f: lambdas.`Lambdas$Functional`<T>?): lambdas.`Lambdas$Functional`<T>? {
  return null
 }
}

open class `Lambdas$2`<T>: lambdas.`Lambdas$Functional`<T> {
 internal constructor(): super()

 open override fun wrap(f: lambdas.`Lambdas$Functional`<T>?): lambdas.`Lambdas$Functional`<T>? {
  return null
 }
}

interface `Lambdas$GenericFunctionalInterface`<T> {
 fun m(i: T?): T?
}

interface `Lambdas$BiFunction`<T, U, R> {
 fun apply(t: T?, u: U?): R?

 fun <V> andThen(after: lambdas.`Lambdas$Function`<*, *>?): lambdas.`Lambdas$BiFunction`<T, U, V>? {
  return { t: T?, u: U? ->
   return after!!.apply(this.apply(t, u))
  }
 }
}

interface `Lambdas$Function`<T, R> {
 fun apply(t: T?): R?

 companion object {
  @JvmStatic
  fun <T_1> identity(): lambdas.`Lambdas$Function`<T_1, T_1>? {
   return { t: T_1? ->
    return t
   }
  }
 }
}

interface `Lambdas$FunctionalInterfaceWithMethodReturningVoid` {
 fun run()
}

open class `Lambdas$3` {
 internal constructor(`$outer_this`: lambdas.Lambdas?): super() {
  this.`this` = `$outer_this`
 }

 @JvmField val `this`: lambdas.Lambdas?
}

open class `Lambdas$Parent` {
 internal constructor(): super()

 @JvmField var fieldInParent: Int = 0

 open fun funInParent() {}
}

open class `Lambdas$LambdaInSubClass`: lambdas.`Lambdas$Parent` {
 internal constructor(): super()

 open fun testLambdaInSubclass() {
  val l: lambdas.`Lambdas$FunctionalInterface`? = { i: Int ->
   this.funInParent()
   this.funInParent()
   this.funInParent()
   var a: Int = this.fieldInParent
   a = this.fieldInParent
   a = this.fieldInParent
   return a
  }
 }
}

interface `Lambdas$GenericJsFunction`<R, T> {
 fun apply(t: T?): R?
}

interface `Lambdas$Thenable`<T> {
 fun then(f1: lambdas.`Lambdas$GenericJsFunction`<java.lang.Void?, T>?, f2: lambdas.`Lambdas$GenericJsFunction`<java.lang.Void?, Throwable?>?)
}

interface `Lambdas$AnotherThenable`<T> {
 fun then(f1: lambdas.`Lambdas$GenericJsFunction`<java.lang.Void?, T>?, f2: lambdas.`Lambdas$GenericJsFunction`<java.lang.Void?, Throwable?>?)
}

class `Lambdas$IdentityFunction`: lambdas.`Lambdas$GenericJsFunction`<Any?, Any?> {
 internal constructor(): super()

 open override fun apply(o: Any?): Any? {
  return o
 }
}

interface `Lambdas$Equals`<T> {
 fun equals(o: Any?): Boolean

 fun get(): T? {
  return null
 }
}

interface `Lambdas$JsSupplier`<T: Number?>: lambdas.`Lambdas$Equals`<T> {
 override fun get(): T?
}

interface `Lambdas$JustADefaultT`<T> {
 fun method(t: T?) {}
}

interface `Lambdas$JustADefaultS`<S> {
 fun method(t: S?) {}
}

interface `Lambdas$MarkerWithDefaultMethod` {
 fun defaultMethod() {}
}
