package lambdas

open class Lambdas {
 constructor(): super()

 @JvmField var field: Int = 100

 open fun call(intf: lambdas.`Lambdas$FunctionalInterface`?, n: Int): Int {
  return this.field + intf!!.m(n)
 }

 open fun testLambdaExpressionStyle() {
  this.call(lambdas.`Lambdas$FunctionalInterface` { i: Int ->
   return i + 1
  }, 10)
 }

 open fun testLambdaBlockStyle() {
  this.call(lambdas.`Lambdas$FunctionalInterface` { i: Int ->
   return i + 2
  }, 10)
 }

 open fun testLambdaCaptureField() {
  this.call(lambdas.`Lambdas$FunctionalInterface` { i: Int ->
   return this.field + i + 1
  }, 10)
 }

 open fun testLambdaCaptureLocal() {
  val x: Int = 1
  this.call(lambdas.`Lambdas$FunctionalInterface` { i: Int ->
   return x + i + 1
  }, 10)
 }

 open fun testLambdaCaptureFieldAndLocal() {
  val x: Int = 1
  this.call(lambdas.`Lambdas$FunctionalInterface` { i: Int ->
   val y: Int = 1
   return x + y + this.field + i + 1
  }, 10)
 }

 open fun funOuter() {}

 open fun testLambdaCallOuterFunction() {
  this.call(lambdas.`Lambdas$FunctionalInterface` { i: Int ->
   this.funOuter()
   this.funOuter()
   this.funOuter()
   return i + 2
  }, 10)
 }

 open fun <T> testInstanceMethodTypeVariableThroughLambda() {
  val wrapped: lambdas.`Lambdas$Functional`<T>? = lambdas.`Lambdas$Functional`<T> { f: lambdas.`Lambdas$Functional`<T>? ->
   return lambdas.`Lambdas$1`<T>(this)
  }
 }

 open fun <T> callWithTypeVariable(intf: lambdas.`Lambdas$GenericFunctionalInterface`<T>?, e: T?): T? {
  return intf!!.m(e)
 }

 open fun callParameterized(intf: lambdas.`Lambdas$GenericFunctionalInterface`<java.lang.Error?>?, e: java.lang.Error?): java.lang.Error? {
  return intf!!.m(e)
 }

 internal open fun <T> callWithBiFunction(fn: lambdas.`Lambdas$BiFunction`<T, kotlin.String?, kotlin.Double?>?): lambdas.`Lambdas$GenericFunctionalInterface`<T>? {
  return null
 }

 open fun <T: kotlin.Enum<T>?> testLambdaWithGenerics() {
  this.callWithTypeVariable(lambdas.`Lambdas$GenericFunctionalInterface`<java.lang.Error?> { i: java.lang.Error? ->
   return i
  }, java.lang.Error())
  this.callParameterized(lambdas.`Lambdas$GenericFunctionalInterface`<java.lang.Error?> { i_1: java.lang.Error? ->
   return i_1
  }, java.lang.Error())
  lambdas.Lambdas.callTypeVariableWithBounds(lambdas.`Lambdas$GenericFunctionalInterface`<kotlin.Enum<T>?> { i_2: kotlin.Enum<T>? ->
   return i_2
  }, null as kotlin.Enum<T>?)
  this.callWithBiFunction(lambdas.`Lambdas$BiFunction`<kotlin.Any?, kotlin.String?, kotlin.Double?> { x: kotlin.Any?, y: kotlin.String? ->
   throw java.lang.RuntimeException()
  })
  val f: lambdas.`Lambdas$Function`<*, *>? = lambdas.`Lambdas$Function`<*, *> { item: T? ->
   return 1L
  }
 }

 open fun testLambdaReturningVoidAsExpression() {
  val runner: lambdas.`Lambdas$FunctionalInterfaceWithMethodReturningVoid`? = lambdas.`Lambdas$FunctionalInterfaceWithMethodReturningVoid` {
   (java.lang.Object() as kotlin.Any)
  }
 }

 open fun testAnonymousInsideLambda() {
  val runner: lambdas.`Lambdas$FunctionalInterfaceWithMethodReturningVoid`? = lambdas.`Lambdas$FunctionalInterfaceWithMethodReturningVoid` {
   lambdas.`Lambdas$3`(this)
  }
 }

 open fun testDefaultMethodsInIntersectionAdaptor() {
  val o: kotlin.Any? = lambdas.`Lambdas$BiFunction`<kotlin.String?, kotlin.String?, kotlin.String?> { t: kotlin.String?, u: kotlin.String? ->
   return null
  } as lambdas.`Lambdas$BiFunction`<kotlin.String?, kotlin.String?, kotlin.String?>? /* & lambdas.`Lambdas$MarkerWithDefaultMethod`? */
 }

 companion object {
  @JvmStatic
  fun testLambdaInStaticContext() {
   val f: lambdas.`Lambdas$FunctionalInterface`? = lambdas.`Lambdas$FunctionalInterface` { i: Int ->
    return i
   }
  }

  @JvmStatic
  fun <T> testStaticMethodTypeVariableThroughLambda() {
   val wrapped: lambdas.`Lambdas$Functional`<T>? = lambdas.`Lambdas$Functional`<T> { f: lambdas.`Lambdas$Functional`<T>? ->
    return lambdas.`Lambdas$2`<T>()
   }
  }

  @JvmStatic
  fun <T: kotlin.Enum<T>?> callTypeVariableWithBounds(intf: lambdas.`Lambdas$GenericFunctionalInterface`<kotlin.Enum<T>?>?, e: kotlin.Enum<T>?): kotlin.Enum<T>? {
   return intf!!.m(e)
  }

  @JvmStatic
  fun m(): kotlin.Any? {
   return null
  }

  @JvmStatic
  fun testLambdaCallingStaticMethod() {
   val f: lambdas.`Lambdas$Function`<kotlin.Any?, *>? = lambdas.`Lambdas$Function`<kotlin.Any?, *> { l: kotlin.Any? ->
    return lambdas.Lambdas.m()
   }
  }

  internal var identityFunction: lambdas.`Lambdas$IdentityFunction`? = null

  @JvmStatic
  fun <E> identity(): lambdas.`Lambdas$GenericJsFunction`<E, E>? {
   if (lambdas.Lambdas.identityFunction === null) {
    lambdas.Lambdas.identityFunction = lambdas.`Lambdas$IdentityFunction`()
   }
   return lambdas.Lambdas.identityFunction as lambdas.`Lambdas$GenericJsFunction`<E, E>?
  }

  @JvmStatic
  fun testJsInteropLambdas() {
   val thenable: lambdas.`Lambdas$Thenable`<kotlin.String?>? = lambdas.`Lambdas$Thenable`<kotlin.String?> { f1: lambdas.`Lambdas$GenericJsFunction`<java.lang.Void?, kotlin.String?>?, f2: lambdas.`Lambdas$GenericJsFunction`<java.lang.Void?, kotlin.Throwable?>? ->
    f1!!.apply(null)
   }
   val otherThenable: lambdas.`Lambdas$AnotherThenable`<kotlin.String?>? = lambdas.`Lambdas$AnotherThenable`<kotlin.String?> { f1_1: lambdas.`Lambdas$GenericJsFunction`<java.lang.Void?, kotlin.String?>?, f2_1: lambdas.`Lambdas$GenericJsFunction`<java.lang.Void?, kotlin.Throwable?>? ->
    f1_1!!.apply(null)
   }
   val stringJsSupplier: lambdas.`Lambdas$JsSupplier`<kotlin.Int?>? = lambdas.`Lambdas$JsSupplier`<kotlin.Int?> {
    return 1
   }
   stringJsSupplier!!.get()
   val equals: lambdas.`Lambdas$Equals`<*>? = stringJsSupplier
   equals!!.equals(null)
   equals!!.get()
  }

  @JvmStatic
  fun <U, V> testIntersectionTyping() {
   var o: kotlin.Any? = lambdas.`Lambdas$GenericFunctionalInterface`<kotlin.String?> { x: kotlin.String? ->
    return x
   } as lambdas.`Lambdas$GenericFunctionalInterface`<kotlin.String?>? /* & lambdas.`Lambdas$JustADefaultT`<kotlin.Number?>? */
   o = lambdas.`Lambdas$GenericFunctionalInterface`<kotlin.String?> { x_1: kotlin.String? ->
    return x_1
   } as lambdas.`Lambdas$GenericFunctionalInterface`<kotlin.String?>? /* & lambdas.`Lambdas$JustADefaultS`<kotlin.Number?>? */
   o = lambdas.`Lambdas$GenericFunctionalInterface`<U> { x_2: U? ->
    return x_2
   } as lambdas.`Lambdas$GenericFunctionalInterface`<U>? /* & lambdas.`Lambdas$JustADefaultS`<V>? */
  }
 }
}

fun interface `Lambdas$FunctionalInterface` {
 fun m(i: Int): Int
}

fun interface `Lambdas$Functional`<T> {
 fun wrap(f: lambdas.`Lambdas$Functional`<T>?): lambdas.`Lambdas$Functional`<T>?
}

open class `Lambdas$1`<T>: lambdas.`Lambdas$Functional`<T> {
 internal constructor(`$outer_this`: lambdas.Lambdas?): super() {
  this.`this` = `$outer_this`
 }

 @JvmField val `this`: lambdas.Lambdas?

 open override fun wrap(f: lambdas.`Lambdas$Functional`<T>?): lambdas.`Lambdas$Functional`<T>? {
  return null
 }
}

open class `Lambdas$2`<T>: lambdas.`Lambdas$Functional`<T> {
 internal constructor(): super()

 open override fun wrap(f: lambdas.`Lambdas$Functional`<T>?): lambdas.`Lambdas$Functional`<T>? {
  return null
 }
}

fun interface `Lambdas$GenericFunctionalInterface`<T> {
 fun m(i: T?): T?
}

fun interface `Lambdas$BiFunction`<T, U, R> {
 fun apply(t: T?, u: U?): R?

 fun <V> andThen(after: lambdas.`Lambdas$Function`<*, *>?): lambdas.`Lambdas$BiFunction`<T, U, V>? {
  return lambdas.`Lambdas$BiFunction`<T, U, V> { t: T?, u: U? ->
   return after!!.apply(this.apply(t, u))
  }
 }
}

fun interface `Lambdas$Function`<T, R> {
 fun apply(t: T?): R?

 companion object {
  @JvmStatic
  fun <T_1> identity(): lambdas.`Lambdas$Function`<T_1, T_1>? {
   return lambdas.`Lambdas$Function`<T_1, T_1> { t: T_1? ->
    return t
   }
  }
 }
}

fun interface `Lambdas$FunctionalInterfaceWithMethodReturningVoid` {
 fun run()
}

open class `Lambdas$3` {
 internal constructor(`$outer_this`: lambdas.Lambdas?): super() {
  this.`this` = `$outer_this`
 }

 @JvmField val `this`: lambdas.Lambdas?
}

open class `Lambdas$Parent` {
 internal constructor(): super()

 @JvmField var fieldInParent: Int = 0

 open fun funInParent() {}
}

open class `Lambdas$LambdaInSubClass`: lambdas.`Lambdas$Parent` {
 internal constructor(): super()

 open fun testLambdaInSubclass() {
  val l: lambdas.`Lambdas$FunctionalInterface`? = lambdas.`Lambdas$FunctionalInterface` { i: Int ->
   this.funInParent()
   this.funInParent()
   this.funInParent()
   var a: Int = this.fieldInParent
   a = this.fieldInParent
   a = this.fieldInParent
   return a
  }
 }
}

fun interface `Lambdas$GenericJsFunction`<R, T> {
 fun apply(t: T?): R?
}

fun interface `Lambdas$Thenable`<T> {
 fun then(f1: lambdas.`Lambdas$GenericJsFunction`<java.lang.Void?, T>?, f2: lambdas.`Lambdas$GenericJsFunction`<java.lang.Void?, kotlin.Throwable?>?)
}

fun interface `Lambdas$AnotherThenable`<T> {
 fun then(f1: lambdas.`Lambdas$GenericJsFunction`<java.lang.Void?, T>?, f2: lambdas.`Lambdas$GenericJsFunction`<java.lang.Void?, kotlin.Throwable?>?)
}

class `Lambdas$IdentityFunction`: lambdas.`Lambdas$GenericJsFunction`<kotlin.Any?, kotlin.Any?> {
 internal constructor(): super()

 open override fun apply(o: kotlin.Any?): kotlin.Any? {
  return o
 }
}

interface `Lambdas$Equals`<T> {
 fun equals(o: kotlin.Any?): Boolean

 fun get(): T? {
  return null
 }
}

fun interface `Lambdas$JsSupplier`<T: kotlin.Number?>: lambdas.`Lambdas$Equals`<T> {
 override fun get(): T?
}

interface `Lambdas$JustADefaultT`<T> {
 fun method(t: T?) {}
}

interface `Lambdas$JustADefaultS`<S> {
 fun method(t: S?) {}
}

interface `Lambdas$MarkerWithDefaultMethod` {
 fun defaultMethod() {}
}
