// Generated from "j2kt/ObjCName.java"
@file:OptIn(ExperimentalObjCName::class)

package j2kt

import javaemul.lang.*
import java.util.HashMap
import java.util.LinkedList
import kotlin.Any
import kotlin.Boolean
import kotlin.Byte
import kotlin.Char
import kotlin.Double
import kotlin.Float
import kotlin.Int
import kotlin.Long
import kotlin.Number
import kotlin.OptIn
import kotlin.Short
import kotlin.String
import kotlin.collections.HashSet
import kotlin.collections.MutableCollection
import kotlin.collections.MutableIterable
import kotlin.collections.MutableIterator
import kotlin.collections.MutableList
import kotlin.collections.MutableListIterator
import kotlin.collections.MutableMap
import kotlin.collections.MutableSet
import kotlin.experimental.ExperimentalObjCName
import kotlin.jvm.JvmField
import kotlin.jvm.JvmStatic

@kotlin.native.ObjCName("NewObjCName", exact = true)
open class ObjCName {
 @JvmField var publicField: Int = 0

 @JvmField var protectedField: Int = 0

 @JvmField var packagePrivateField_pp_j2kt: Int = 0

 @JvmField var privateField_private_2: Int = 0

 constructor()

 constructor(
  @kotlin.native.ObjCName("Integer", exact = false) i: Int
 )

 constructor(
  @kotlin.native.ObjCName("Int", exact = false) i: Int,
  @kotlin.native.ObjCName("withNSString", exact = false) s: String?
 )

 companion object {
  @kotlin.native.ObjCName("publicStaticField", exact = false)
  @JvmField var publicStaticField: Int = 0

  @kotlin.native.ObjCName("protectedStaticField", exact = false)
  @JvmField var protectedStaticField: Int = 0

  @JvmField var packagePrivateStaticField_pp_j2kt: Int = 0

  @JvmField var privateStaticField_private_2: Int = 0

  @kotlin.native.ObjCName("objectField", exact = false)
  @JvmField var objectField: Any? = null

  @kotlin.native.ObjCName("stringField", exact = false)
  @JvmField var stringField: String? = null

  @kotlin.native.ObjCName("selfField", exact = false)
  @JvmField var selfField: ObjCName? = null

  @kotlin.native.ObjCName("iterable", exact = false)
  @JvmField var iterable: MutableIterable<String?>? = null

  @kotlin.native.ObjCName("iterator", exact = false)
  @JvmField var iterator: MutableIterator<String?>? = null

  @kotlin.native.ObjCName("collection", exact = false)
  @JvmField var collection: MutableCollection<Any?>? = null

  @kotlin.native.ObjCName("theAlloc", exact = false)
  @JvmField var alloc: Int = 0

  @kotlin.native.ObjCName("theInit", exact = false)
  @JvmField var init: Int = 0

  @kotlin.native.ObjCName("extern__", exact = false)
  @JvmField var extern: Int = 0

  @kotlin.native.ObjCName("inline__", exact = false)
  @JvmField var inline: Int = 0

  @kotlin.native.ObjCName("NULL__", exact = false)
  @JvmField var NULL__: Int = 0

  @kotlin.native.ObjCName("BOOLEAN_FALSE", exact = false)
  const val BOOLEAN_FALSE: Boolean = false

  @kotlin.native.ObjCName("BOOLEAN_TRUE", exact = false)
  const val BOOLEAN_TRUE: Boolean = true

  @kotlin.native.ObjCName("CHAR", exact = false)
  const val CHAR: Char = 'a'

  @kotlin.native.ObjCName("CHAR_APOSTROPHE", exact = false)
  const val CHAR_APOSTROPHE: Char = '\''

  @kotlin.native.ObjCName("CHAR_BACKSLASH", exact = false)
  const val CHAR_BACKSLASH: Char = '\\'

  @kotlin.native.ObjCName("CHAR_UNICODE", exact = false)
  const val CHAR_UNICODE: Char = '\u1231'

  @kotlin.native.ObjCName("BYTE", exact = false)
  const val BYTE: Byte = (123).toByte()

  @kotlin.native.ObjCName("SHORT", exact = false)
  const val SHORT: Short = (123).toShort()

  @kotlin.native.ObjCName("INT", exact = false)
  const val INT: Int = 123

  @kotlin.native.ObjCName("INT_MIN_VALUE", exact = false)
  @JvmField val INT_MIN_VALUE: Int = Int.MIN_VALUE

  @kotlin.native.ObjCName("INT_MAX_VALUE", exact = false)
  @JvmField val INT_MAX_VALUE: Int = Int.MIN_VALUE

  @kotlin.native.ObjCName("LONG", exact = false)
  const val LONG: Long = 123L

  @kotlin.native.ObjCName("LONG_MIN_VALUE", exact = false)
  @JvmField val LONG_MIN_VALUE: Long = Long.MIN_VALUE

  @kotlin.native.ObjCName("LONG_MAX_VALUE", exact = false)
  @JvmField val LONG_MAX_VALUE: Long = Long.MAX_VALUE

  @kotlin.native.ObjCName("FLOAT", exact = false)
  const val FLOAT: Float = 123.0f

  @kotlin.native.ObjCName("FLOAT_NAN", exact = false)
  @JvmField val FLOAT_NAN: Float = Float.NaN

  @kotlin.native.ObjCName("FLOAT_NEGATIVE_INFINITY", exact = false)
  @JvmField val FLOAT_NEGATIVE_INFINITY: Float = Float.NEGATIVE_INFINITY

  @kotlin.native.ObjCName("FLOAT_POSITIVE_INFINITY", exact = false)
  @JvmField val FLOAT_POSITIVE_INFINITY: Float = Float.POSITIVE_INFINITY

  @kotlin.native.ObjCName("FLOAT_MIN_VALUE", exact = false)
  @JvmField val FLOAT_MIN_VALUE: Float = Float.MIN_VALUE

  @kotlin.native.ObjCName("FLOAT_MIN_NORMAL", exact = false)
  @JvmField val FLOAT_MIN_NORMAL: Float = Float.MIN_NORMAL

  @kotlin.native.ObjCName("FLOAT_MIN_EXPONENT", exact = false)
  @JvmField val FLOAT_MIN_EXPONENT: Float = Float.MIN_EXPONENT.toFloat()

  @kotlin.native.ObjCName("FLOAT_MAX_VALUE", exact = false)
  @JvmField val FLOAT_MAX_VALUE: Float = Float.MAX_VALUE

  @kotlin.native.ObjCName("FLOAT_MAX_EXPONENT", exact = false)
  @JvmField val FLOAT_MAX_EXPONENT: Float = Float.MAX_EXPONENT.toFloat()

  @kotlin.native.ObjCName("DOUBLE", exact = false)
  const val DOUBLE: Double = 123.0

  @kotlin.native.ObjCName("DOUBLE_NAN", exact = false)
  @JvmField val DOUBLE_NAN: Double = Double.NaN

  @kotlin.native.ObjCName("DOUBLE_NEGATIVE_INFINITY", exact = false)
  @JvmField val DOUBLE_NEGATIVE_INFINITY: Double = Double.NEGATIVE_INFINITY

  @kotlin.native.ObjCName("DOUBLE_POSITIVE_INFINITY", exact = false)
  @JvmField val DOUBLE_POSITIVE_INFINITY: Double = Double.POSITIVE_INFINITY

  @kotlin.native.ObjCName("DOUBLE_MIN_VALUE", exact = false)
  @JvmField val DOUBLE_MIN_VALUE: Double = Double.MIN_VALUE

  @kotlin.native.ObjCName("DOUBLE_MIN_NORMAL", exact = false)
  @JvmField val DOUBLE_MIN_NORMAL: Double = Double.MIN_NORMAL

  @kotlin.native.ObjCName("DOUBLE_MIN_EXPONENT", exact = false)
  @JvmField val DOUBLE_MIN_EXPONENT: Double = Double.MIN_EXPONENT.toDouble()

  @kotlin.native.ObjCName("DOUBLE_MAX_VALUE", exact = false)
  @JvmField val DOUBLE_MAX_VALUE: Double = Double.MAX_VALUE

  @kotlin.native.ObjCName("DOUBLE_MAX_EXPONENT", exact = false)
  @JvmField val DOUBLE_MAX_EXPONENT: Double = Double.MAX_EXPONENT.toDouble()

  @kotlin.native.ObjCName("STRING", exact = false)
  const val STRING: String = "foo"

  @JvmStatic
  @kotlin.native.ObjCName("newFoo", exact = false)
  fun foo() {}

  @JvmStatic
  @kotlin.native.ObjCName("newProtectedFoo", exact = false)
  fun protectedFoo() {}

  @JvmStatic
  @kotlin.native.ObjCName("newFooFrom", exact = false)
  fun newFoo(
   @kotlin.native.ObjCName("Int", exact = false) i: Int
  ) {}

  @JvmStatic
  @kotlin.native.ObjCName("newFooFrom", exact = false)
  fun foo(
   @kotlin.native.ObjCName("Int", exact = false) s: String?,
   @kotlin.native.ObjCName("withInteger", exact = false) i: Int
  ) {}

  @JvmStatic
  fun foo(
   @kotlin.native.ObjCName("withNSString", exact = false) s: String?,
   @kotlin.native.ObjCName("withNSString", exact = false) i: String?
  ) {}

  @JvmStatic
  fun alloc() {}

  @JvmStatic
  fun allocFoo() {}

  @JvmStatic
  fun allocatedFoo() {}

  @JvmStatic
  fun initFoo() {}

  @JvmStatic
  fun newFoo() {}

  @JvmStatic
  fun copyFoo() {}

  @JvmStatic
  fun mutableCopyFoo() {}

  @JvmStatic
  fun reservedParamNames(
   @kotlin.native.ObjCName("withInt", exact = false) extern: Int,
   @kotlin.native.ObjCName("withInt", exact = false) struct: Int,
   @kotlin.native.ObjCName("withInt", exact = false) register: Int,
   @kotlin.native.ObjCName("withInt", exact = false) inline: Int
  ) {}

  @JvmStatic
  fun nativeTypes(
   @kotlin.native.ObjCName("withNSString", exact = false) s: String?,
   @kotlin.native.ObjCName("withId", exact = false) o: Any?,
   @kotlin.native.ObjCName("withNSNumber", exact = false) n: Number?
  ): String? {
   return s
  }

  @JvmStatic
  fun iterableType(
   @kotlin.native.ObjCName("withJavaLangIterable", exact = false) l: MutableIterable<String?>?
  ) {}

  @JvmStatic
  fun iteratorType(
   @kotlin.native.ObjCName("withJavaUtilIterator", exact = false) l: MutableIterator<String?>?
  ) {}

  @JvmStatic
  fun listIteratorType(
   @kotlin.native.ObjCName("withJavaUtilListIterator", exact = false) l: MutableListIterator<String?>?
  ) {}

  @JvmStatic
  fun collectionType(
   @kotlin.native.ObjCName("withJavaUtilCollection", exact = false) l: MutableCollection<String?>?
  ) {}

  @JvmStatic
  fun listType(
   @kotlin.native.ObjCName("withJavaUtilList", exact = false) l: MutableList<String?>?
  ) {}

  @JvmStatic
  fun setType(
   @kotlin.native.ObjCName("withJavaUtilSet", exact = false) l: MutableSet<String?>?
  ) {}

  @JvmStatic
  fun mapType(
   @kotlin.native.ObjCName("withJavaUtilMap", exact = false) l: MutableMap<String?, String?>?
  ) {}

  @JvmStatic
  fun linkedListType(
   @kotlin.native.ObjCName("withJavaUtilLinkedList", exact = false) l: LinkedList<String?>?
  ) {}

  @JvmStatic
  fun hashSetType(
   @kotlin.native.ObjCName("withJavaUtilHashSet", exact = false) l: HashSet<String?>?
  ) {}

  @JvmStatic
  fun hashMapType(
   @kotlin.native.ObjCName("withJavaUtilHashMap", exact = false) l: HashMap<String?, String?>?
  ) {}
 }

 @kotlin.native.ObjCName("InnerClassNewName", exact = true)
 open inner class InnerClassOldName {}

 @kotlin.native.ObjCName("NewObjCName_Foo", exact = true)
 enum class Foo {
  @kotlin.native.ObjCName("theAllocFoo", exact = false)
  allocFoo,
  @kotlin.native.ObjCName("theInitFoo", exact = false)
  initFoo,
  @kotlin.native.ObjCName("theNewFoo", exact = false)
  newFoo,
  @kotlin.native.ObjCName("theCopyFoo", exact = false)
  copyFoo,
  @kotlin.native.ObjCName("theMutableCopyFoo", exact = false)
  mutableCopyFoo,
  @kotlin.native.ObjCName("register__", exact = false)
  register,
  @kotlin.native.ObjCName("struct__", exact = false)
  struct,
  @kotlin.native.ObjCName("NULL__", exact = false)
  NULL__,
  @kotlin.native.ObjCName("YES__", exact = false)
  YES,
  @kotlin.native.ObjCName("NO__", exact = false)
  NO;

  companion object {
   @JvmStatic
   fun withOrdinal(
    @kotlin.native.ObjCName("withInt", exact = false) ordinal: Int
   ): ObjCName.Foo? {
    return ObjCName.Foo.values()!![ordinal]
   }
  }
 }
}
