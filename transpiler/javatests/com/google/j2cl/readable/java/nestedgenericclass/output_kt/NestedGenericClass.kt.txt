package nestedgenericclass

open class NestedGenericClass<T> {
 open fun <S> `fun`(t: S?) {
  TODO("expression.qualify needs rendering: NestedGenericClass.this)")
  TODO("expression.qualify needs rendering: NestedGenericClass.this)")
 }

 open fun <T> bar() {
  TODO("expression.qualify needs rendering: NestedGenericClass.this)").bar()
 }

 open fun test() {
  val n: nestedgenericclass.NestedGenericClass<Number?>? = nestedgenericclass.NestedGenericClass<Number?>()
  val a: nestedgenericclass.`NestedGenericClass$A`<Error?, Number?>? = TODO("expression.qualify needs rendering: n)")
  val b: nestedgenericclass.`NestedGenericClass$A$B`<Exception?, Error?, Number?>? = TODO("expression.qualify needs rendering: a)")
  TODO("expression.qualify needs rendering: n)")
  TODO("expression.qualify needs rendering: n.new C.<init>())")
 }
}

open class `NestedGenericClass$A`<T, T> {
 @JvmField val `this`: nestedgenericclass.NestedGenericClass<T>?
}

open class `NestedGenericClass$A$B`<T, T, T> {
 @JvmField val `this`: nestedgenericclass.`NestedGenericClass$A`<T, T>?

 internal constructor() {}

 internal constructor(u: U?) {}
}

open class `NestedGenericClass$C`<T> {
 @JvmField val `this`: nestedgenericclass.NestedGenericClass<T>?

 @JvmField var c: T? = null
}

open class `NestedGenericClass$C$D`<T> {
 @JvmField val `this`: nestedgenericclass.`NestedGenericClass$C`<T>?

 @JvmField var d: T? = null
}

open class `NestedGenericClass$1E`<S, S, T> {
 @JvmField val `this`: nestedgenericclass.NestedGenericClass<T>?
}

open class `NestedGenericClass$1F`<S, T> {
 @JvmField val `this`: nestedgenericclass.NestedGenericClass<T>?

 @JvmField var f: S? = null
}

open class `NestedGenericClass$1G`<T, T, T> {
 @JvmField val `this`: nestedgenericclass.NestedGenericClass<T>?

 open fun <T> bar() {
  TODO("expression.qualify needs rendering: \$1G.this)")
 }
}

open class `NestedGenericClass$1G$1H`<T, T, T, T, T> {
 @JvmField val `this`: nestedgenericclass.`NestedGenericClass$1G`<T, T, T>?
}
