package genericmethod

open class GenericMethod<T_2> {
 constructor(): super()

 open fun <T_1, S> foo(f: T_1?, s: S?) {}

 open fun `fun`(o: kotlin.Any?) {}

 open fun <T_1: java.lang.Exception?> `fun`(t: T_1?) {}

 open fun <T_1: java.lang.Error?> `fun`(t: T_1?) {
  genericmethod.`GenericMethod$1`<T_1, T_2>(this)
  if (true) {}
  genericmethod.`GenericMethod$1LocalClass`<T_1, T_1, T_2>(this)
 }

 open fun <T_1> bar(): genericmethod.GenericMethod<T_1>? {
  return null
 }

 open fun <T_1> `fun`(array: Array<T_1>?): Array<T_1>? {
  return array
 }

 open fun <T_1> checked(): T_1? {
  return null
 }

 open fun <T_1> unchecked(): T_1? {
  return null
 }

 open fun test() {
  val g: genericmethod.GenericMethod<kotlin.Number?>? = genericmethod.GenericMethod<kotlin.Number?>()
  g!!.foo(g, g)
  g!!.foo(java.lang.Error(), java.lang.Exception())
  g!!.`fun`((java.lang.Object() as kotlin.Any))
  g!!.`fun`(java.lang.Exception())
  g!!.`fun`(java.lang.Error())
  g!!.`fun`(arrayOf<kotlin.String?>("asdf"))
  var s: kotlin.String? = this.checked()
  s = this.unchecked()
 }

 companion object {
  @JvmStatic
  fun acceptsContent(content: genericmethod.`GenericMethod$Content`?) {}

  @JvmStatic
  fun acceptsString(string: kotlin.String?) {}

  @JvmStatic
  fun testErasureCast_wildcard() {
   val list: java.util.List<genericmethod.`GenericMethod$Container`<*>?>? = null
   val content: genericmethod.`GenericMethod$Content`? = list!!.get(0)!!.get()
   genericmethod.GenericMethod.acceptsString(content!!.getProp())
   genericmethod.GenericMethod.acceptsContent(content)
   val nestedWildcardList: java.util.List<genericmethod.`GenericMethod$SuperContainer`<*>?>? = null
   val nestedContent: genericmethod.`GenericMethod$Content`? = nestedWildcardList!!.get(0)!!.get()!!.get()
   genericmethod.GenericMethod.acceptsString(nestedContent!!.getProp())
   genericmethod.GenericMethod.acceptsContent(nestedContent)
   val deepWildcardList: java.util.List<genericmethod.`GenericMethod$SuperContainer`<genericmethod.`GenericMethod$Container`<*>?>?>? = null
   val deepContent: genericmethod.`GenericMethod$Content`? = deepWildcardList!!.get(0)!!.get()!!.get()
   genericmethod.GenericMethod.acceptsString(deepContent!!.getProp())
   genericmethod.GenericMethod.acceptsContent(deepContent)
  }

  @JvmStatic
  fun <CT: genericmethod.`GenericMethod$Container`<C>?, C: genericmethod.`GenericMethod$Content`?> testErasureCast_typeVariable() {
   val list: java.util.List<genericmethod.`GenericMethod$Container`<C>?>? = null
   val content: genericmethod.`GenericMethod$Content`? = list!!.get(0)!!.get()
   genericmethod.GenericMethod.acceptsString(content!!.getProp())
   genericmethod.GenericMethod.acceptsContent(content)
   val nestedTypeVariableList: java.util.List<genericmethod.`GenericMethod$SuperContainer`<CT>?>? = null
   val nestedContent: genericmethod.`GenericMethod$Content`? = nestedTypeVariableList!!.get(0)!!.get()!!.get()
   genericmethod.GenericMethod.acceptsString(nestedContent!!.getProp())
   genericmethod.GenericMethod.acceptsContent(nestedContent)
   val deepTypeVariableList: java.util.List<genericmethod.`GenericMethod$SuperContainer`<genericmethod.`GenericMethod$Container`<C>?>?>? = null
   val deepContent: genericmethod.`GenericMethod$Content`? = deepTypeVariableList!!.get(0)!!.get()!!.get()
   genericmethod.GenericMethod.acceptsString(deepContent!!.getProp())
   genericmethod.GenericMethod.acceptsContent(deepContent)
  }
 }
}

open class `GenericMethod$1`<T_1: java.lang.Error?, T_2>: genericmethod.GenericMethod<T_1> {
 @JvmField val `this`: genericmethod.GenericMethod<T_2>?

 internal constructor(`$outer_this`: genericmethod.GenericMethod<T_2>?): super() {
  this.`this` = `$outer_this`
 }

 open fun fun2(t: T_1?) {}

 open fun <T_2> fun2(t: T_2?) {}
}

open class `GenericMethod$SuperContainer`<C: genericmethod.`GenericMethod$Container`<*>?> {
 internal constructor(): super()

 internal open fun get(): C? {
  return null
 }
}

open class `GenericMethod$Container`<CT: genericmethod.`GenericMethod$Content`?> {
 internal constructor(): super()

 internal open fun get(): CT? {
  return null
 }
}

open class `GenericMethod$Content` {
 internal constructor(): super()

 internal open fun getProp(): kotlin.String? {
  return null
 }
}

open class `GenericMethod$1LocalClass`<T, T_1: java.lang.Error?, T_2>: genericmethod.GenericMethod<T> {
 @JvmField val `this`: genericmethod.GenericMethod<T_2>?

 internal constructor(`$outer_this`: genericmethod.GenericMethod<T_2>?): super() {
  this.`this` = `$outer_this`
 }

 open fun fun2(t: T?) {}

 open fun <T_3: kotlin.Number?> fun2(t: T_3?) {}
}
