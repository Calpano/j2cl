// Generated from "autoboxing/AutoBoxing.java"
package autoboxing

import javaemul.lang.*
import kotlin.jvm.*

open class AutoBoxing {
 open fun box(b: kotlin.Boolean): kotlin.Boolean? {
  return kotlin.Boolean.valueOf(b)
 }

 open fun box(d: kotlin.Double): kotlin.Double? {
  return kotlin.Double.valueOf(d)
 }

 open fun box(b: kotlin.Byte): kotlin.Byte? {
  return kotlin.Byte.valueOf(b)
 }

 open fun box(f: kotlin.Float): kotlin.Float? {
  return kotlin.Float.valueOf(f)
 }

 open fun box(i: kotlin.Int): kotlin.Int? {
  return kotlin.Int.valueOf(i)
 }

 open fun box(l: kotlin.Long): kotlin.Long? {
  return kotlin.Long.valueOf(l)
 }

 open fun box(s: kotlin.Short): kotlin.Short? {
  return kotlin.Short.valueOf(s)
 }

 open fun box(c: kotlin.Char): kotlin.Char? {
  return kotlin.Char.valueOf(c)
 }

 open fun unbox(b: kotlin.Boolean?): kotlin.Boolean {
  return b!!.booleanValue()
 }

 open fun unbox(d: kotlin.Double?): kotlin.Double {
  return d!!.toDouble()
 }

 open fun unbox(b: kotlin.Byte?): kotlin.Byte {
  return b!!.toByte()
 }

 open fun unbox(f: kotlin.Float?): kotlin.Float {
  return f!!.toFloat()
 }

 open fun unbox(i: kotlin.Int?): kotlin.Int {
  return i!!.toInt()
 }

 open fun unbox(l: kotlin.Long?): kotlin.Long {
  return l!!.toLong()
 }

 open fun unbox(s: kotlin.Short?): kotlin.Short {
  return s!!.toShort()
 }

 open fun unbox(c: kotlin.Char?): kotlin.Char {
  return c!!.toChar()
 }

 open fun takesAndReturnsPrimitiveDouble(d: kotlin.Double): kotlin.Double {
  return d
 }

 open fun takesAndReturnsVoid(v: kotlin.Unit?): kotlin.Unit? {
  return null
 }

 open fun takesFloatVarArgs(vararg elements: kotlin.Float?) {}

 open fun takesObjectAndReturnsPrimitiveDouble(o: kotlin.Any?): kotlin.Double {
  return o as kotlin.Double
 }

 open fun sumWithoutBoxing(vararg numbers: kotlin.Any?): kotlin.Double {
  var sum: kotlin.Double = 0.0
  FOR_EACH@ for (number in (numbers as kotlin.Array<*>?)!!) {
   sum = sum + (number as kotlin.Double?)!!.toDouble()
  }
  return sum
 }

 open fun sumWithoutBoxingJsVarargs(vararg numbers: kotlin.Any?): kotlin.Double {
  var sum: kotlin.Double = 0.0
  FOR_EACH@ for (number in (numbers as kotlin.Array<*>?)!!) {
   sum = sum + (number as kotlin.Double?)!!.toDouble()
  }
  return sum
 }

 open fun testBoxing() {
  var bool: kotlin.Boolean = true
  var d: kotlin.Double = 2.2
  var b: kotlin.Byte = 1.toByte()
  var f: kotlin.Float = 1.1f
  var i: kotlin.Int = 1
  var l: kotlin.Long = 2L
  var s: kotlin.Short = 1.toShort()
  var c: kotlin.Char = 'a'
  var boxBool: kotlin.Boolean? = kotlin.Boolean.valueOf(bool)
  var boxD: kotlin.Double? = kotlin.Double.valueOf(d)
  var boxB: kotlin.Byte? = kotlin.Byte.valueOf(b)
  var boxF: kotlin.Float? = kotlin.Float.valueOf(f)
  var boxI: kotlin.Int? = kotlin.Int.valueOf(i)
  var boxL: kotlin.Long? = kotlin.Long.valueOf(l)
  var boxS: kotlin.Short? = kotlin.Short.valueOf(s)
  var boxC: kotlin.Char? = kotlin.Char.valueOf(c)
  boxBool = kotlin.Boolean.valueOf(true)
  boxD = kotlin.Double.valueOf(2.2)
  boxB = kotlin.Byte.valueOf((1).toByte())
  boxF = kotlin.Float.valueOf(1.1f)
  boxI = kotlin.Int.valueOf(1)
  boxL = kotlin.Long.valueOf(2L)
  boxS = kotlin.Short.valueOf((1).toShort())
  boxC = kotlin.Char.valueOf('\u0001')
  boxC = kotlin.Char.valueOf('a')
  bool = this.unbox(kotlin.Boolean.valueOf(bool))
  d = this.unbox(kotlin.Double.valueOf(d))
  b = this.unbox(kotlin.Byte.valueOf(b))
  f = this.unbox(kotlin.Float.valueOf(f))
  i = this.unbox(kotlin.Int.valueOf(i))
  l = this.unbox(kotlin.Long.valueOf(l))
  s = this.unbox(kotlin.Short.valueOf(s))
  c = this.unbox(kotlin.Char.valueOf(c))
  var unusedDouble: kotlin.Double = this.takesObjectAndReturnsPrimitiveDouble(4)
  unusedDouble = this.sumWithoutBoxing(TODO("JsDocCastExpression"), TODO("JsDocCastExpression"), TODO("JsDocCastExpression"), TODO("JsDocCastExpression"), TODO("JsDocCastExpression"))
  unusedDouble = this.sumWithoutBoxingJsVarargs(TODO("JsDocCastExpression"), TODO("JsDocCastExpression"), TODO("JsDocCastExpression"), TODO("JsDocCastExpression"), TODO("JsDocCastExpression"))
  this.takesFloatVarArgs(kotlin.Float.valueOf(1.1f), kotlin.Float.valueOf(97.0f), kotlin.Float.valueOf(2.2.toFloat()))
  var o: kotlin.Any?
  o = kotlin.Double.valueOf(2.2)
  o = kotlin.Float.valueOf(1.1f)
  o = kotlin.Int.valueOf(1)
  o = kotlin.Char.valueOf('a')
  boxBool = kotlin.Boolean.valueOf(boxBool!!.booleanValue() && boxBool!!.booleanValue())
  boxD = kotlin.Double.valueOf(boxD!!.toDouble() + boxD!!.toDouble())
  boxI = kotlin.Int.valueOf(boxI!!.toInt() / boxI!!.toInt())
  boxL = kotlin.Long.valueOf(boxL!!.toLong() / boxL!!.toLong())
  boxBool = kotlin.Boolean.valueOf(!boxBool!!.booleanValue())
  boxI = kotlin.Int.valueOf(+ boxI!!.toInt())
  boxI = kotlin.Int.valueOf(- boxI!!.toInt())
  boxI = kotlin.Int.valueOf(boxI!!.toInt().shl(boxI!!.toInt()))
  boxI = kotlin.Int.valueOf(boxI!!.toInt().shl(boxL!!.toLong().toInt()))
  boxL = kotlin.Long.valueOf(boxL!!.toLong().shl(boxI!!.toInt()))
  boxL = kotlin.Long.valueOf(boxL!!.toLong().shl(boxL!!.toLong().toInt()))
  o = kotlin.Int.valueOf(15)
 }

 open fun testUnboxing() {
  var boxBool: kotlin.Boolean? = kotlin.Boolean(true)
  var boxD: kotlin.Double? = kotlin.Double(2.2)
  var boxB: kotlin.Byte? = kotlin.Byte(1.toByte())
  var boxF: kotlin.Float? = kotlin.Float(1.1f)
  var boxI: kotlin.Int? = kotlin.Int(1)
  var boxL: kotlin.Long? = kotlin.Long(1L)
  var boxS: kotlin.Short? = kotlin.Short(1.toShort())
  var boxC: kotlin.Char? = kotlin.Char('a')
  var bool: kotlin.Boolean = boxBool!!.booleanValue()
  var d: kotlin.Double = boxD!!.toDouble()
  val b: kotlin.Byte = boxB!!.toByte()
  var f: kotlin.Float = boxF!!.toFloat()
  var i: kotlin.Int = boxI!!.toInt()
  var l: kotlin.Long = boxL!!.toLong()
  val s: kotlin.Short = boxS!!.toShort()
  val c: kotlin.Char = boxC!!.toChar()
  boxBool = this.box(boxBool!!.booleanValue())
  boxD = this.box(boxD!!.toDouble())
  boxB = this.box(boxB!!.toByte())
  boxF = this.box(boxF!!.toFloat())
  boxI = this.box(boxI!!.toInt())
  boxL = this.box(boxL!!.toLong())
  boxS = this.box(boxS!!.toShort())
  boxC = this.box(boxC!!.toChar())
  d = boxB!!.toByte().toDouble()
  d = boxF!!.toFloat().toDouble()
  d = boxI!!.toInt().toDouble()
  d = boxL!!.toLong().toDouble()
  d = boxS!!.toShort().toDouble()
  d = boxC!!.toChar().code.toDouble()
  this.takesAndReturnsPrimitiveDouble(boxB!!.toByte().toDouble())
  this.takesAndReturnsPrimitiveDouble(boxF!!.toFloat().toDouble())
  this.takesAndReturnsPrimitiveDouble(boxI!!.toInt().toDouble())
  this.takesAndReturnsPrimitiveDouble(boxL!!.toLong().toDouble())
  this.takesAndReturnsPrimitiveDouble(boxS!!.toShort().toDouble())
  this.takesAndReturnsPrimitiveDouble(boxC!!.toChar().code.toDouble())
  val v: kotlin.Unit? = this.takesAndReturnsVoid(this.takesAndReturnsVoid(null))
  bool = boxBool!!.booleanValue() && boxBool!!.booleanValue()
  d = boxD!!.toDouble() + boxD!!.toDouble()
  f = boxF!!.toFloat() - boxF!!.toFloat()
  i = boxI!!.toInt() * boxI!!.toInt()
  l = boxL!!.toLong() / boxL!!.toLong()
  bool = !boxBool!!.booleanValue()
  i = + boxI!!.toInt()
  i = - boxI!!.toInt()
  i = boxI!!.toInt().inv()
  boxD = kotlin.Double.valueOf(- boxD!!.toDouble())
  boxI = kotlin.Int.valueOf(- boxI!!.toInt())
  SWITCH@ do {
   CASE@ do {
    when (boxI!!.toInt()) {
     else -> {
      break@CASE
     }
    }
    break@SWITCH
   } while (false)
  } while (false)
  i = i + kotlin.run {
   boxI = kotlin.Int.valueOf(boxI!!.toInt() + kotlin.run {
    i = i + boxI!!.toInt()
    i
   })
   boxI
  }!!.toInt()
  i = i.shl(boxI!!.toInt())
  i = i.shl(boxL!!.toLong().toInt())
  l = l.shl(boxI!!.toInt())
  l = l.shl(boxL!!.toLong().toInt())
 }

 open fun testUnboxingBoolean() {
  var boxB1: kotlin.Boolean? = kotlin.Boolean(true)
  val boxB2: kotlin.Boolean? = kotlin.Boolean(false)
  var br: kotlin.Boolean
  var boxr: kotlin.Boolean
  boxr = boxB1 === boxB2
  br = boxB1 === boxB2
  assert(boxr)
  assert(br)
  boxr = boxB1 !== boxB2
  br = boxB1 !== boxB2
  assert(boxr)
  assert(br)
  boxr = boxB1!!.booleanValue().xor(boxB2!!.booleanValue())
  br = boxB1!!.booleanValue().xor(boxB2!!.booleanValue())
  assert(boxr)
  assert(br)
  boxr = boxB1!!.booleanValue().and(boxB2!!.booleanValue())
  br = boxB1!!.booleanValue().and(boxB2!!.booleanValue())
  assert(boxr)
  assert(br)
  boxr = boxB1!!.booleanValue().or(boxB2!!.booleanValue())
  br = boxB1!!.booleanValue().or(boxB2!!.booleanValue())
  assert(boxr)
  assert(br)
  boxr = boxB1!!.booleanValue() && boxB2!!.booleanValue()
  br = boxB1!!.booleanValue() && boxB2!!.booleanValue()
  assert(boxr)
  assert(br)
  boxr = boxB1!!.booleanValue() || boxB2!!.booleanValue()
  br = boxB1!!.booleanValue() || boxB2!!.booleanValue()
  assert(boxr)
  assert(br)
  boxr = kotlin.run {
   boxB1 = boxB2
   boxB1
  }!!.booleanValue()
  br = kotlin.run {
   boxB1 = boxB2
   boxB1
  }!!.booleanValue()
  assert(boxr)
  assert(br)
  boxr = kotlin.run {
   boxB1 = kotlin.Boolean.valueOf(boxB1!!.booleanValue().and(boxB2!!.booleanValue()))
   boxB1
  }!!.booleanValue()
  br = kotlin.run {
   boxB1 = kotlin.Boolean.valueOf(boxB1!!.booleanValue().and(boxB2!!.booleanValue()))
   boxB1
  }!!.booleanValue()
  assert(boxr)
  assert(br)
  boxr = kotlin.run {
   boxB1 = kotlin.Boolean.valueOf(boxB1!!.booleanValue().or(boxB2!!.booleanValue()))
   boxB1
  }!!.booleanValue()
  br = kotlin.run {
   boxB1 = kotlin.Boolean.valueOf(boxB1!!.booleanValue().or(boxB2!!.booleanValue()))
   boxB1
  }!!.booleanValue()
  assert(boxr)
  assert(br)
  boxr = kotlin.run {
   boxB1 = kotlin.Boolean.valueOf(boxB1!!.booleanValue().xor(boxB2!!.booleanValue()))
   boxB1
  }!!.booleanValue()
  br = kotlin.run {
   boxB1 = kotlin.Boolean.valueOf(boxB1!!.booleanValue().xor(boxB2!!.booleanValue()))
   boxB1
  }!!.booleanValue()
  assert(boxr)
  assert(br)
  var boxB: kotlin.Boolean? = null
  boxB = kotlin.Boolean.valueOf(!boxB!!.booleanValue())
  boxB = kotlin.Boolean.valueOf(boxB!!.booleanValue() && boxB!!.booleanValue())
  boxB = if (boxB!!.booleanValue()) boxB else boxB
  if (boxB!!.booleanValue()) {}
  var b: kotlin.Boolean = false
  b = b.or(kotlin.run {
   boxB = kotlin.Boolean.valueOf(boxB!!.booleanValue().or(kotlin.run {
    b = b.or(boxB!!.booleanValue())
    b
   }))
   boxB
  }!!.booleanValue())
 }

 open fun testUnboxingEquality() {
  val boxB: kotlin.Boolean? = kotlin.Boolean(true)
  val b: kotlin.Boolean = false
  assert(boxB === boxB)
  assert(boxB!!.booleanValue() === b)
  assert(b !== b)
  assert(b !== boxB!!.booleanValue())
  val boxI: kotlin.Int? = kotlin.Int(1)
  val i: kotlin.Int = 1
  assert(boxI === boxI)
  assert(boxI!!.toInt() === i)
  assert(i !== i)
  assert(i !== boxI!!.toInt())
 }

 open fun testAssertStatement() {
  val boxB: kotlin.Boolean? = kotlin.Boolean(true)
  val b: kotlin.Boolean = true
  assert(boxB!!.booleanValue())
  assert(b)
 }

 open fun testUnbox_withCast() {
  open class ___1Supplier<T> {
   open fun get(): T {
    return null as T
   }
  }
  val supplier: ___1Supplier<kotlin.Int?>? = ___1Supplier<kotlin.Int?>()
  val i: kotlin.Int = supplier!!.get()!!.toInt()
 }

 companion object {
  @kotlin.jvm.JvmField val COMPILE_TIME_CONSTANT: kotlin.Float = 1.1f

  @kotlin.jvm.JvmStatic
  fun <T: kotlin.Long?> testUnboxingFromTypeVariable() {
   var n: T = kotlin.Long.valueOf(10L)
   var l: kotlin.Long = n!!.toLong()
   assert(l === 10L)
   n = kotlin.Long.valueOf(n!!.toLong() + 1L)
   open class ___1Local<T: kotlin.Long?> {
    open fun toLong(l: T): kotlin.Long {
     assert(l!!.equals(kotlin.Long.valueOf(11L)))
     return l!!.toLong()
    }
   }
   l = ___1Local<kotlin.Long?>().toLong(kotlin.Long.valueOf(11L))
   assert(l === 11L)
  }

  @kotlin.jvm.JvmStatic
  fun <T> testUnboxingFromIntersectionType() where T: kotlin.Long?, T: kotlin.Comparable<kotlin.Long>? {
   var n: T = kotlin.Long.valueOf(10L)
   var l: kotlin.Long = n!!.toLong()
   assert(l === 10L)
   n = kotlin.Long.valueOf(n!!.toLong() + 1L)
   open class ___2Local<T> where T: kotlin.Long?, T: kotlin.Comparable<kotlin.Long>?, T: kotlin.Long?, T: kotlin.Comparable<kotlin.Long>? {
    open fun toLong(l: T): kotlin.Long {
     assert(l!!.equals(kotlin.Long.valueOf(11L)))
     return l!!.toLong()
    }
   }
   l = ___2Local<kotlin.Long?>().toLong(kotlin.Long.valueOf(11L))
   assert(l === 11L)
   val i: kotlin.Int = kotlin.Int.valueOf(10)!!.toInt()
  }
 }
}
