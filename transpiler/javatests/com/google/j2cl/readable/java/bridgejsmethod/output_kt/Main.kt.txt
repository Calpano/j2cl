package bridgejsmethod

open class Main {
 companion object {
  @JvmStatic
  fun test() {
   val a: bridgejsmethod.`Main$A`? = bridgejsmethod.`Main$A`<Int?>()
   a!!.`fun`(1)
   a!!.bar(1)
   val b: bridgejsmethod.`Main$B`? = bridgejsmethod.`Main$B`()
   b!!.`fun`("abc")
   b!!.bar("abc")
   val c: bridgejsmethod.`Main$C`? = bridgejsmethod.`Main$C`()
   c!!.`fun`(1)
   c!!.bar(1)
   val d: bridgejsmethod.`Main$D`? = bridgejsmethod.`Main$D`()
   d!!.`fun`(1)
   d!!.bar(1)
   val e: bridgejsmethod.`Main$E`? = bridgejsmethod.`Main$E`()
   e!!.`fun`("abc")
   e!!.bar("abc")
   val h: bridgejsmethod.`Main$H`<Int?>? = bridgejsmethod.`Main$H`<Int?>()
   h!!.enclose(1)
   val l: bridgejsmethod.`Main$L`<Int?>? = bridgejsmethod.`Main$L`<Int?>()
   l!!.`fun`("foo", 1)
  }
 }
}

open class `Main$A`<T> {
 open fun `fun`(t: T?): T? {
  return t
 }

 open fun bar(t: T?) {}
}

interface `Main$I`<T: Number?> {
 fun `fun`(t: T?): T?
}

interface `Main$J`<T> {
 fun bar(t: T?)
}

open class `Main$B`: bridgejsmethod.`Main$A`<String?>() {
 open override fun `fun`(s: String?): String? {
  return s
 }

 open override fun bar(s: String?) {}
}

open class `Main$C`: bridgejsmethod.`Main$A`<Int?>() {
 open override fun `fun`(i: Int?): Int? {
  return i
 }
}

open class `Main$D`: bridgejsmethod.`Main$I`<Int?>, bridgejsmethod.`Main$A`<Int?>() {
 open override fun `fun`(i: Int?): Int? {
  return i
 }
}

open class `Main$E`: bridgejsmethod.`Main$J`<String?>, bridgejsmethod.`Main$B`() {}

open class `Main$F`: bridgejsmethod.`Main$I`<Int?>, bridgejsmethod.`Main$A`<Int?>() {}

interface `Main$G`<V> {
 fun enclose(value: V?): V?
}

open class `Main$H`<V>: bridgejsmethod.`Main$G`<V> {
 open override fun enclose(value: V?): V? {
  return null
 }
}

open class `Main$K`<K1, K2> {
 internal open fun `fun`(k1: K1?, k2: K2?) {}
}

open class `Main$L`<L1>: bridgejsmethod.`Main$K`<String?, L1>() {
 internal open override fun `fun`(string: String?, l1: L1?) {}
}

interface `Main$M` {
 fun getB(): bridgejsmethod.`Main$B`?
}

abstract class `Main$N`: bridgejsmethod.`Main$M` {
 @JvmField val `this`: bridgejsmethod.Main?

 internal constructor() {}

 abstract open override fun getB(): bridgejsmethod.`Main$B`?
}

open class `Main$O`: bridgejsmethod.`Main$N`() {
 @JvmField val `this`: bridgejsmethod.Main?

 private var b: bridgejsmethod.`Main$B`? = null

 open override fun getB(): bridgejsmethod.`Main$B`? {
  return this.b
 }
}

interface `Main$P` {
 fun getKey(): String?
}

abstract class `Main$Q`: bridgejsmethod.`Main$P` {
 @JvmField val `this`: bridgejsmethod.Main?

 abstract open override fun getKey(): String?
}

abstract class `Main$R`: bridgejsmethod.`Main$Q`() {
 @JvmField val `this`: bridgejsmethod.Main?

 open override fun getKey(): String? {
  return null
 }
}

open class `Main$S`: bridgejsmethod.`Main$R`() {
 @JvmField val `this`: bridgejsmethod.Main?
}

open class `Main$GrandParent`<T> {
 @JvmField val `this`: bridgejsmethod.Main?

 open fun jsMethod(t: T?) {}

 open fun method(t: T?) {}
}

open class `Main$Parent`<T: bridgejsmethod.`Main$Parent`<T>?>: bridgejsmethod.`Main$GrandParent`<T>() {
 @JvmField val `this`: bridgejsmethod.Main?

 open override fun jsMethod(t: T?) {}

 open override fun method(t: T?) {}
}

open class `Main$Child`: bridgejsmethod.`Main$Parent`<bridgejsmethod.`Main$Child`?>() {
 @JvmField val `this`: bridgejsmethod.Main?
}
