package interfaces

open class Main {
 constructor(): super()

 internal open fun testInterfaceMembers() {
  val i: interfaces.`Main$Interface`<*>? = interfaces.`Main$Implementor`(this)
  i!!.interfaceMethod()
  i!!.defaultMethod(null)
  interfaces.`Main$Interface`.staticInterfaceMethod()
  val x: Int = run {
   interfaces.`Main$Implementor`(this)
   interfaces.`Main$Interface`.a
  } + interfaces.`Main$Interface`.b
 }
}

fun interface `Main$Interface`<T> {
 fun interfaceMethod()

 fun defaultMethod(t: T?) {
  this.privateMethod(t)
 }

 internal fun privateMethod(t: T?) {}

 companion object {
  @JvmField val a: Int = 1

  @JvmField val b: Int = 2

  @JvmStatic
  fun staticInterfaceMethod() {}
 }
}

fun interface `Main$SubInterface`: interfaces.`Main$Interface`<kotlin.String?> {
 override fun defaultMethod(s: kotlin.String?) {
  super.defaultMethod(s)
 }
}

open class `Main$Implementor`: interfaces.`Main$SubInterface`, interfaces.`Main$Interface`<kotlin.String?> {
 internal constructor(`$outer_this`: interfaces.Main?): super() {
  this.`this` = `$outer_this`
 }

 @JvmField val `this`: interfaces.Main?

 open override fun interfaceMethod() {}
}

abstract class `Main$AbstractImplementor`: interfaces.`Main$SubInterface` {
 internal constructor(`$outer_this`: interfaces.Main?): super() {
  this.`this` = `$outer_this`
 }

 @JvmField val `this`: interfaces.Main?
}
