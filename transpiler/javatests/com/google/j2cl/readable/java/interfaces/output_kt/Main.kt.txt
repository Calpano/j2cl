package interfaces

open class Main {
 internal open fun testInterfaceMembers() {
  val i: interfaces.`Main$Interface`? = TODO("expression.qualify needs rendering: Main.this)")
  i!!.interfaceMethod()
  i!!.defaultMethod(null)
  interfaces.`Main$Interface`.staticInterfaceMethod()
  val x: Int = run {
   TODO("expression.qualify needs rendering: Main.this)")
   interfaces.`Main$Interface`.a
  } + interfaces.`Main$Interface`.b
 }
}

interface `Main$Interface`<T> {
 fun interfaceMethod()

 fun defaultMethod(t: T?) {
  this.privateMethod(t)
 }

 private fun privateMethod(t: T?) {}

 companion object {
  @JvmField val a: Int = 1

  @JvmField val b: Int = 2

  @JvmStatic
  fun staticInterfaceMethod() {}
 }
}

interface `Main$SubInterface`: interfaces.`Main$Interface`<String?> {
 override fun defaultMethod(s: String?) {
  super.defaultMethod(s)
 }
}

open class `Main$Implementor`: interfaces.`Main$SubInterface`, interfaces.`Main$Interface`<String?> {
 @JvmField val `this`: interfaces.Main?

 open override fun interfaceMethod() {}
}

abstract class `Main$AbstractImplementor`: interfaces.`Main$SubInterface` {
 @JvmField val `this`: interfaces.Main?
}
